---
phase: 02-linear-history-cli
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/tract/operations/history.py
  - src/tract/operations/diff.py
  - src/tract/tract.py
  - src/tract/__init__.py
  - tests/test_operations.py
autonomous: true

must_haves:
  truths:
    - "User can view commit history (log) with per-commit token counts and optional operation filter"
    - "User can check current state (status) showing HEAD position, branch name, detached state, and token budget usage"
    - "User can compare any two commits (diff) and see textual differences in content with token deltas"
    - "EDIT commits auto-resolve: diff on an edit commit automatically finds the original target"
    - "Diff returns structured DiffResult with MessageDiff entries, not raw text"
  artifacts:
    - path: "src/tract/operations/history.py"
      provides: "StatusInfo dataclass, status computation logic"
      contains: "class StatusInfo"
    - path: "src/tract/operations/diff.py"
      provides: "DiffResult, MessageDiff dataclasses, diff computation"
      contains: "class DiffResult"
    - path: "src/tract/tract.py"
      provides: "Tract.log() enhanced, Tract.status(), Tract.diff()"
      contains: "def status"
    - path: "tests/test_operations.py"
      provides: "Tests for log, status, diff operations"
      min_lines: 150
  key_links:
    - from: "src/tract/tract.py"
      to: "src/tract/operations/history.py"
      via: "Tract.status() delegates to history module"
      pattern: "from tract.operations.history"
    - from: "src/tract/tract.py"
      to: "src/tract/operations/diff.py"
      via: "Tract.diff() delegates to diff module"
      pattern: "from tract.operations.diff"
    - from: "src/tract/operations/diff.py"
      to: "difflib"
      via: "unified_diff for content comparison"
      pattern: "difflib.unified_diff"
---

<objective>
Build the three read-oriented SDK operations (enhanced log, status, diff) that let users inspect their linear commit history.

Purpose: These are the "read" counterpart to Plan 01's "write" operations (reset, checkout). Together they complete the SDK layer that the CLI (Plan 03) will wrap. Log shows history, status shows current state, diff compares commits.

Output: New operations modules for history and diff, structured data models (StatusInfo, DiffResult, MessageDiff), enhanced Tract.log() with op_filter, new Tract.status() and Tract.diff() methods, comprehensive tests.
</objective>

<execution_context>
@C:\Users\jinwi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jinwi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-linear-history-cli/02-CONTEXT.md
@.planning/phases/02-linear-history-cli/02-RESEARCH.md
@.planning/phases/02-linear-history-cli/02-01-SUMMARY.md
@src/tract/tract.py
@src/tract/protocols.py
@src/tract/storage/sqlite.py
@src/tract/engine/compiler.py
@src/tract/engine/commit.py
@src/tract/models/commit.py
@src/tract/models/content.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: History and diff operations modules + data models</name>
  <files>
    src/tract/operations/history.py
    src/tract/operations/diff.py
  </files>
  <action>
**1. Create `src/tract/operations/history.py`:**

```python
"""History operations: status computation."""
from __future__ import annotations
from dataclasses import dataclass, field
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from tract.models.commit import CommitInfo

@dataclass(frozen=True)
class StatusInfo:
    """Current tract status information returned by Tract.status()."""
    head_hash: str | None
    branch_name: str | None       # None if detached
    is_detached: bool
    commit_count: int             # total commits in chain from HEAD
    token_count: int              # compiled token count (from compile())
    token_budget_max: int | None  # None if no budget configured
    token_source: str
    recent_commits: list[CommitInfo] = field(default_factory=list)  # last 3 commits
```

This is a pure data model. The computation logic lives in `Tract.status()` which orchestrates calling log, compile, and assembling the StatusInfo.

**2. Create `src/tract/operations/diff.py`:**

```python
"""Diff operations: structured comparison between two compiled contexts."""
from __future__ import annotations
import difflib
import json
from dataclasses import dataclass, field
from typing import Literal, TYPE_CHECKING

if TYPE_CHECKING:
    from tract.protocols import Message
```

Define data models:

```python
@dataclass(frozen=True)
class MessageDiff:
    """Diff for a single message position."""
    index: int
    status: Literal["added", "removed", "modified", "unchanged"]
    role_a: str | None = None     # role in commit A (None if added)
    role_b: str | None = None     # role in commit B (None if removed)
    content_type_a: str | None = None
    content_type_b: str | None = None
    content_diff_lines: list[str] = field(default_factory=list)  # unified diff lines
    token_delta: int = 0

@dataclass(frozen=True)
class DiffStat:
    """Summary statistics for a diff."""
    messages_added: int = 0
    messages_removed: int = 0
    messages_modified: int = 0
    messages_unchanged: int = 0
    total_token_delta: int = 0

@dataclass(frozen=True)
class DiffResult:
    """Structured diff between two commits."""
    commit_a: str  # hash
    commit_b: str  # hash
    message_diffs: list[MessageDiff] = field(default_factory=list)
    stat: DiffStat = field(default_factory=DiffStat)
    generation_config_changes: dict[str, tuple] = field(default_factory=dict)
    # generation_config_changes maps field name -> (old_value, new_value)
```

Implement core diff function:

```python
def compute_diff(
    commit_a_hash: str,
    commit_b_hash: str,
    messages_a: list[Message],
    messages_b: list[Message],
    configs_a: list[dict],
    configs_b: list[dict],
    token_counts_a: list[int] | None = None,
    token_counts_b: list[int] | None = None,
) -> DiffResult:
```

Algorithm:
- Use `difflib.SequenceMatcher` on message content to align messages between A and B
- For each aligned pair: if content differs, generate `difflib.unified_diff()` lines
- Track role changes (role_a != role_b)
- Calculate token deltas per message
- Compute DiffStat summary
- Compare generation configs: find fields that changed between the merged config sets

Helper function for serializing message content to diffable text:
```python
def _serialize_message(msg: Message) -> str:
    """Serialize a Message to diffable text representation."""
    lines = []
    lines.append(f"role: {msg.role}")
    if msg.name:
        lines.append(f"name: {msg.name}")
    lines.append(f"---")
    lines.append(msg.content)
    return "\n".join(lines)
```

For the diff algorithm, use a simpler approach than SequenceMatcher since messages are ordered:
- Walk both lists in parallel using indices
- Use length comparison: shorter list = removals at end, longer list = additions at end
- For overlapping positions: compare content. If different, generate unified diff.
- Actually, a proper approach: use `difflib.SequenceMatcher` on the list of serialized messages to find matching blocks, then classify each position as added/removed/modified/unchanged.

Implementation detail for unified_diff:
```python
old_lines = _serialize_message(msg_a).splitlines(keepends=True)
new_lines = _serialize_message(msg_b).splitlines(keepends=True)
diff_lines = list(difflib.unified_diff(
    old_lines, new_lines,
    fromfile=f"commit {commit_a_hash[:8]}",
    tofile=f"commit {commit_b_hash[:8]}",
    lineterm="",
))
```

For generation_config_changes: merge all configs from A into one dict (latest wins) and all from B, then find keys where values differ. This gives a high-level "what config changed between these two points."

Actually, per CONTEXT.md: generation_config changes should be shown in the diff header. The simplest approach: compare the config at each message position. If message N has config change, include it in that MessageDiff. But since DiffResult already has a top-level generation_config_changes dict, compute the union of all per-message config changes there.

Simpler approach for generation configs: compare last config in A vs last config in B (since they represent the "state" at each commit point). Store as `generation_config_changes: dict[str, tuple[Any, Any]]`.
  </action>
  <verify>
`python -c "from tract.operations.history import StatusInfo; from tract.operations.diff import DiffResult, MessageDiff, DiffStat, compute_diff; print('OK')"` succeeds.
  </verify>
  <done>
StatusInfo dataclass exists in operations/history.py. DiffResult, MessageDiff, DiffStat dataclasses exist in operations/diff.py. compute_diff() function accepts two sets of messages/configs and returns structured DiffResult with unified diff lines per message, role changes, token deltas, and generation config changes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Tract facade methods (log, status, diff) + exports + tests</name>
  <files>
    src/tract/tract.py
    src/tract/__init__.py
    tests/test_operations.py
  </files>
  <action>
**1. Enhance `Tract.log()` in `src/tract/tract.py`:**

Add `op_filter` parameter:
```python
def log(
    self,
    limit: int = 20,
    *,
    op_filter: CommitOperation | None = None,
) -> list[CommitInfo]:
    """Walk commit history from HEAD backward.

    Args:
        limit: Maximum number of commits to return. Default 20.
        op_filter: If set, only include commits with this operation type.

    Returns:
        List of CommitInfo in reverse chronological order (newest first).
    """
    current_head = self.head
    if current_head is None:
        return []

    # Fetch more than limit if filtering (may need to walk further)
    fetch_limit = limit * 3 if op_filter else limit
    ancestors = self._commit_repo.get_ancestors(current_head, limit=fetch_limit)
    infos = [self._commit_engine._row_to_info(row) for row in ancestors]

    if op_filter is not None:
        infos = [i for i in infos if i.operation == op_filter]

    return infos[:limit]
```

Change default limit from 10 to 20 per CONTEXT.md decision.

**2. Add `Tract.status()` method:**

```python
def status(self) -> StatusInfo:
    """Get current tract status.

    Returns StatusInfo with HEAD position, branch name, detached state,
    token count (compiled), budget info, and last 3 commits.
    """
    from tract.operations.history import StatusInfo

    current_head = self.head
    branch_name = self._ref_repo.get_current_branch(self._tract_id)
    is_detached = self._ref_repo.is_detached(self._tract_id)

    # Get compiled token count (uses cache if available)
    token_count = 0
    token_source = ""
    commit_count = 0
    if current_head is not None:
        compiled = self.compile()
        token_count = compiled.token_count
        token_source = compiled.token_source
        commit_count = compiled.commit_count

    # Get token budget max
    token_budget_max = None
    if self._config.token_budget and self._config.token_budget.max_tokens:
        token_budget_max = self._config.token_budget.max_tokens

    # Get last 3 commits for preview
    recent = self.log(limit=3)

    return StatusInfo(
        head_hash=current_head,
        branch_name=branch_name,
        is_detached=is_detached,
        commit_count=commit_count,
        token_count=token_count,
        token_budget_max=token_budget_max,
        token_source=token_source,
        recent_commits=recent,
    )
```

**3. Add `Tract.diff()` method:**

```python
def diff(
    self,
    commit_a: str | None = None,
    commit_b: str | None = None,
) -> DiffResult:
    """Compare two commits and return structured diff.

    Args:
        commit_a: First commit (hash or prefix). If None and commit_b is
            an EDIT commit, auto-resolves to the edit target.
        commit_b: Second commit (hash or prefix). Defaults to HEAD.

    Returns:
        DiffResult with per-message diffs, token deltas, and config changes.

    Raises:
        TraceError: If no commits exist or references can't be resolved.
    """
    from tract.operations.diff import compute_diff

    # Default commit_b to HEAD
    if commit_b is None:
        current_head = self.head
        if current_head is None:
            raise TraceError("No commits to diff")
        commit_b = current_head
    else:
        commit_b = self.resolve_commit(commit_b)

    # Auto-resolve EDIT commits: if commit_b is an EDIT, diff against its target
    row_b = self._commit_repo.get(commit_b)
    if row_b is None:
        raise CommitNotFoundError(commit_b)

    if commit_a is None:
        if row_b.operation == CommitOperation.EDIT and row_b.response_to:
            commit_a = row_b.response_to
        elif row_b.parent_hash:
            commit_a = row_b.parent_hash
        else:
            # First commit, diff against empty
            commit_a = None
    else:
        commit_a = self.resolve_commit(commit_a)

    # Compile both commits to get their messages
    if commit_a is not None:
        compiled_a = self._compiler.compile(self._tract_id, commit_a)
    else:
        compiled_a = CompiledContext(messages=[], token_count=0, commit_count=0, token_source="")

    compiled_b = self._compiler.compile(self._tract_id, commit_b)

    return compute_diff(
        commit_a_hash=commit_a or "(empty)",
        commit_b_hash=commit_b,
        messages_a=compiled_a.messages,
        messages_b=compiled_b.messages,
        configs_a=compiled_a.generation_configs,
        configs_b=compiled_b.generation_configs,
    )
```

Add necessary imports at top of tract.py:
```python
from tract.exceptions import CommitNotFoundError, TraceError
```
(TraceError is already imported, add CommitNotFoundError if not present)

**4. Update `src/tract/__init__.py`:**

Add exports:
```python
from tract.operations.history import StatusInfo
from tract.operations.diff import DiffResult, MessageDiff, DiffStat
```

Add to `__all__`:
```python
"StatusInfo",
"DiffResult",
"MessageDiff",
"DiffStat",
```

**5. Create `tests/test_operations.py`** with comprehensive tests:

Test categories for **log enhancement** (~5 tests):
- `test_log_default_limit_20`: Verify default limit changed from 10 to 20
- `test_log_with_op_filter_append`: Create mixed APPEND+EDIT commits, filter by APPEND only
- `test_log_with_op_filter_edit`: Filter by EDIT only
- `test_log_empty_tract`: Returns empty list
- `test_log_op_filter_no_matches`: Returns empty list when no commits match filter

Test categories for **status** (~8 tests):
- `test_status_empty_tract`: head_hash=None, branch_name=None (or "main" if HEAD exists but no commits -- actually with symbolic refs, before first commit HEAD doesn't exist so branch_name should be None), commit_count=0
- `test_status_with_commits`: Shows correct head_hash, branch_name="main", commit_count, token_count
- `test_status_detached_head`: After checkout to specific commit, is_detached=True, branch_name=None
- `test_status_with_token_budget`: Configure budget, verify token_budget_max is populated
- `test_status_without_budget`: token_budget_max is None
- `test_status_recent_commits`: Verify last 3 commits are returned in recent_commits
- `test_status_fewer_than_3_commits`: If only 1 commit, recent_commits has 1 entry
- `test_status_token_count_is_compiled`: Verify token_count matches compile().token_count (not sum of raw)

Test categories for **diff** (~12 tests):
- `test_diff_two_commits`: Create A (append), then B (append). Diff A vs B shows added message.
- `test_diff_against_head_default`: Diff with only commit_a specified, commit_b defaults to HEAD
- `test_diff_edit_auto_resolve`: Create commit A, then edit of A. `diff(commit_b=edit_hash)` auto-resolves to diff against A's original content vs edit's new content.
- `test_diff_first_commit_vs_empty`: Diff with no commit_a and commit_b is first commit. Shows all messages as "added".
- `test_diff_identical_commits`: Diff A vs A returns all "unchanged" messages.
- `test_diff_modified_message`: Two commits with different content at same position (via edit). Shows "modified" with unified diff lines.
- `test_diff_role_change`: Edit changes role of a message. MessageDiff shows role_a != role_b.
- `test_diff_generation_config_change`: Two commits with different generation_config. DiffResult.generation_config_changes populated.
- `test_diff_stat`: Verify DiffStat counts (added, removed, modified, unchanged, total_token_delta).
- `test_diff_by_prefix`: Use short prefix to reference commits in diff.
- `test_diff_no_commits_raises`: Diff on empty tract raises TraceError.
- `test_diff_invalid_commit_raises`: Diff with nonexistent hash raises CommitNotFoundError.

Use `Tract.open(":memory:")` for all tests. Follow existing test conventions.

Aim for ~25-30 tests total.
  </action>
  <verify>
Run `python -m pytest tests/ -x -q` -- all tests pass (existing + Plan 01 navigation + new operations tests).
Specifically:
1. `python -m pytest tests/test_operations.py -v` -- all new tests pass
2. `python -m pytest tests/ -x -q` -- full suite passes
  </verify>
  <done>
Tract.log() has op_filter parameter and default limit 20. Tract.status() returns StatusInfo with HEAD, branch, detached state, compiled token count, budget info, and last 3 commits. Tract.diff() returns structured DiffResult with per-message unified diffs, role changes, token deltas, generation config changes, and EDIT auto-resolution. All data models exported from tract package. All tests pass including ~25-30 new operation tests.
  </done>
</task>

</tasks>

<verification>
1. `Tract.log(op_filter=CommitOperation.APPEND)` filters correctly
2. `Tract.status()` returns StatusInfo with correct branch_name, is_detached, token_count, budget info
3. `Tract.status()` in detached HEAD shows is_detached=True, branch_name=None
4. `Tract.diff(commit_a, commit_b)` returns DiffResult with per-message diffs
5. `Tract.diff(commit_b=edit_hash)` auto-resolves EDIT to diff against target
6. DiffResult.stat has correct counts (added, removed, modified, unchanged)
7. All tests pass (existing + Plan 01 + Plan 02)
</verification>

<success_criteria>
- StatusInfo, DiffResult, MessageDiff, DiffStat data models exist and are exported
- Tract.log() supports op_filter parameter, default limit 20
- Tract.status() returns complete StatusInfo
- Tract.diff() returns structured DiffResult with unified diff lines
- EDIT auto-resolution works in diff
- All existing + new tests pass (~300+ total)
</success_criteria>

<output>
After completion, create `.planning/phases/02-linear-history-cli/02-02-SUMMARY.md`
</output>
