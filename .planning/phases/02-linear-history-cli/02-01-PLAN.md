---
phase: 02-linear-history-cli
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/tract/exceptions.py
  - src/tract/storage/repositories.py
  - src/tract/storage/sqlite.py
  - src/tract/operations/__init__.py
  - src/tract/operations/navigation.py
  - src/tract/protocols.py
  - src/tract/tract.py
  - src/tract/__init__.py
  - tests/test_navigation.py
autonomous: true

must_haves:
  truths:
    - "User can reset HEAD to a previous commit (soft keeps content accessible, hard discards forward history)"
    - "User can checkout a specific commit for read-only inspection (detached HEAD blocks commits)"
    - "User can reference commits by short hash prefix (minimum 4 chars)"
    - "Symbolic refs resolve HEAD through refs/heads/main when attached"
    - "checkout - returns to previous position via PREV_HEAD ref"
  artifacts:
    - path: "src/tract/exceptions.py"
      provides: "DetachedHeadError, AmbiguousPrefixError"
      contains: "class DetachedHeadError"
    - path: "src/tract/storage/repositories.py"
      provides: "ABC methods for prefix query, symbolic ref ops"
      contains: "get_by_prefix"
    - path: "src/tract/storage/sqlite.py"
      provides: "SQLite implementations of prefix query, symbolic ref ops"
      contains: "def get_by_prefix"
    - path: "src/tract/operations/navigation.py"
      provides: "reset and checkout logic"
      contains: "def reset"
    - path: "src/tract/tract.py"
      provides: "Tract.reset(), Tract.checkout(), Tract.resolve_commit()"
      contains: "def reset"
    - path: "tests/test_navigation.py"
      provides: "Tests for reset, checkout, prefix matching, symbolic refs, detached HEAD"
      min_lines: 100
  key_links:
    - from: "src/tract/tract.py"
      to: "src/tract/operations/navigation.py"
      via: "Tract methods delegate to navigation module"
      pattern: "from tract.operations"
    - from: "src/tract/operations/navigation.py"
      to: "src/tract/storage/sqlite.py"
      via: "Navigation uses ref repo symbolic ref methods"
      pattern: "attach_head|detach_head|is_detached"
    - from: "src/tract/tract.py"
      to: "src/tract/storage/sqlite.py"
      via: "Tract.resolve_commit() uses get_by_prefix"
      pattern: "get_by_prefix"
---

<objective>
Build the storage infrastructure (symbolic refs, prefix matching) and navigation operations (reset, checkout) that all other Phase 2 features depend on.

Purpose: Symbolic refs enable detached HEAD (checkout) and attached HEAD (normal operations). Prefix matching enables user-friendly commit references. Reset and checkout are the two write operations that manipulate HEAD position. All must exist before log/status/diff can correctly report state.

Output: New `operations/` package with navigation module, extended storage layer with symbolic ref and prefix methods, new exceptions, and Tract facade methods for reset() and checkout().
</objective>

<execution_context>
@C:\Users\jinwi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jinwi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-linear-history-cli/02-CONTEXT.md
@.planning/phases/02-linear-history-cli/02-RESEARCH.md
@src/tract/tract.py
@src/tract/storage/repositories.py
@src/tract/storage/sqlite.py
@src/tract/storage/schema.py
@src/tract/exceptions.py
@src/tract/protocols.py
@src/tract/__init__.py
@src/tract/engine/commit.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Storage infrastructure -- symbolic refs, prefix matching, new exceptions</name>
  <files>
    src/tract/exceptions.py
    src/tract/storage/repositories.py
    src/tract/storage/sqlite.py
    src/tract/protocols.py
  </files>
  <action>
**1. Add new exceptions to `src/tract/exceptions.py`:**

```python
class DetachedHeadError(TraceError):
    """Raised when attempting to commit in detached HEAD state."""
    def __init__(self) -> None:
        super().__init__(
            "Cannot commit in detached HEAD state. "
            "Use 'tract checkout main' to return to your branch."
        )

class AmbiguousPrefixError(TraceError):
    """Raised when a commit hash prefix matches multiple commits."""
    def __init__(self, prefix: str, candidates: list[str]) -> None:
        self.prefix = prefix
        self.candidates = candidates
        candidate_str = ", ".join(c[:12] + "..." for c in candidates[:5])
        super().__init__(
            f"Ambiguous prefix '{prefix}'. Matches: {candidate_str}"
        )
```

**2. Extend `CommitRepository` ABC in `src/tract/storage/repositories.py`:**

Add abstract method:
```python
@abstractmethod
def get_by_prefix(self, prefix: str, tract_id: str | None = None) -> CommitRow | None:
    """Find commit by hash prefix (min 4 chars).

    Raises AmbiguousPrefixError if multiple matches.
    Returns None if no match.
    """
    ...
```

**3. Extend `RefRepository` ABC in `src/tract/storage/repositories.py`:**

Add abstract methods:
```python
@abstractmethod
def is_detached(self, tract_id: str) -> bool:
    """Check if HEAD is detached (points directly to commit, not symbolic ref)."""
    ...

@abstractmethod
def attach_head(self, tract_id: str, branch_name: str) -> None:
    """Set HEAD as symbolic ref to a branch (e.g., refs/heads/main)."""
    ...

@abstractmethod
def detach_head(self, tract_id: str, commit_hash: str) -> None:
    """Set HEAD as direct ref to a commit hash (detached state)."""
    ...

@abstractmethod
def get_ref(self, tract_id: str, ref_name: str) -> str | None:
    """Get the commit hash for any ref by name. Returns None if not found."""
    ...

@abstractmethod
def set_ref(self, tract_id: str, ref_name: str, commit_hash: str) -> None:
    """Set or create a named ref pointing to a commit hash."""
    ...

@abstractmethod
def delete_ref(self, tract_id: str, ref_name: str) -> None:
    """Delete a named ref. No-op if ref doesn't exist."""
    ...

@abstractmethod
def get_current_branch(self, tract_id: str) -> str | None:
    """Get the branch name HEAD points to, or None if detached."""
    ...
```

**4. Implement in `SqliteCommitRepository` in `src/tract/storage/sqlite.py`:**

```python
def get_by_prefix(self, prefix: str, tract_id: str | None = None) -> CommitRow | None:
    if len(prefix) < 4:
        raise ValueError("Commit hash prefix must be at least 4 characters")
    stmt = select(CommitRow).where(CommitRow.commit_hash.startswith(prefix))
    if tract_id:
        stmt = stmt.where(CommitRow.tract_id == tract_id)
    matches = list(self._session.execute(stmt).scalars().all())
    if len(matches) == 0:
        return None
    if len(matches) == 1:
        return matches[0]
    from tract.exceptions import AmbiguousPrefixError
    raise AmbiguousPrefixError(prefix, [m.commit_hash for m in matches[:5]])
```

**5. Implement symbolic ref methods in `SqliteRefRepository` in `src/tract/storage/sqlite.py`:**

Update `get_head()` to resolve symbolic refs:
```python
def get_head(self, tract_id: str) -> str | None:
    stmt = select(RefRow).where(
        RefRow.tract_id == tract_id, RefRow.ref_name == "HEAD"
    )
    ref = self._session.execute(stmt).scalar_one_or_none()
    if ref is None:
        return None
    # If symbolic ref, follow the chain
    if ref.symbolic_target:
        target_ref_stmt = select(RefRow).where(
            RefRow.tract_id == tract_id, RefRow.ref_name == ref.symbolic_target
        )
        target_ref = self._session.execute(target_ref_stmt).scalar_one_or_none()
        return target_ref.commit_hash if target_ref else None
    return ref.commit_hash
```

CRITICAL: `update_head()` must continue to work for backward compat. When HEAD is symbolic (attached), `update_head()` should update the branch ref that HEAD points to. When HEAD is direct (detached), it updates commit_hash directly. This ensures all 267 existing tests pass.
```python
def update_head(self, tract_id: str, commit_hash: str) -> None:
    stmt = select(RefRow).where(
        RefRow.tract_id == tract_id, RefRow.ref_name == "HEAD"
    )
    ref = self._session.execute(stmt).scalar_one_or_none()
    if ref is None:
        # First commit: create HEAD as symbolic ref -> refs/heads/main
        # and create the branch ref
        self._session.add(
            RefRow(tract_id=tract_id, ref_name="HEAD",
                   commit_hash=None, symbolic_target="refs/heads/main")
        )
        self._session.add(
            RefRow(tract_id=tract_id, ref_name="refs/heads/main",
                   commit_hash=commit_hash)
        )
    elif ref.symbolic_target:
        # HEAD is symbolic (attached): update the target branch ref
        branch_stmt = select(RefRow).where(
            RefRow.tract_id == tract_id, RefRow.ref_name == ref.symbolic_target
        )
        branch_ref = self._session.execute(branch_stmt).scalar_one_or_none()
        if branch_ref is None:
            self._session.add(
                RefRow(tract_id=tract_id, ref_name=ref.symbolic_target,
                       commit_hash=commit_hash)
            )
        else:
            branch_ref.commit_hash = commit_hash
    else:
        # HEAD is direct (detached): update commit_hash
        ref.commit_hash = commit_hash
    self._session.flush()
```

Implement `is_detached()`, `attach_head()`, `detach_head()`, `get_ref()`, `set_ref()`, `delete_ref()`, `get_current_branch()` following the patterns from RESEARCH.md Pattern 4.

`get_current_branch()` reads HEAD's symbolic_target, extracts branch name from "refs/heads/{name}" pattern. Returns None if HEAD is detached or doesn't exist.

**6. Add `StatusInfo` dataclass to `src/tract/protocols.py`:**

```python
@dataclass(frozen=True)
class StatusInfo:
    """Current tract status information."""
    head_hash: str | None
    branch_name: str | None  # None if detached
    is_detached: bool
    commit_count: int
    token_count: int  # compiled token count
    token_budget_max: int | None  # None if no budget
    token_source: str
    recent_commits: list  # list of CommitInfo (last 3)
```

Note: Import CommitInfo would cause circular import, so use `list` type annotation and document that it contains CommitInfo objects. Or better: keep StatusInfo in operations/history.py (Plan 02) and only add the storage infrastructure here. Actually, leave StatusInfo for Plan 02 -- this plan focuses on storage + navigation only.

DO NOT add StatusInfo to protocols.py in this plan. Plan 02 will handle it.
  </action>
  <verify>
Run `python -m pytest tests/ -x -q` -- all 267 existing tests must pass. The symbolic ref migration in update_head() is the critical backward-compat risk. If existing tests fail, the issue is in get_head() or update_head() symbolic ref resolution.
  </verify>
  <done>
All 267 existing tests pass. New exceptions (DetachedHeadError, AmbiguousPrefixError) exist. CommitRepository has get_by_prefix(). RefRepository has is_detached(), attach_head(), detach_head(), get_ref(), set_ref(), delete_ref(), get_current_branch(). SqliteCommitRepository and SqliteRefRepository implement all new methods. get_head() resolves symbolic refs. update_head() creates symbolic HEAD on first commit and updates branch ref when attached.
  </done>
</task>

<task type="auto">
  <name>Task 2: Navigation operations -- reset, checkout, resolve_commit + Tract facade + tests</name>
  <files>
    src/tract/operations/__init__.py
    src/tract/operations/navigation.py
    src/tract/tract.py
    src/tract/__init__.py
    src/tract/engine/commit.py
    tests/test_navigation.py
  </files>
  <action>
**1. Create `src/tract/operations/__init__.py`** -- empty file.

**2. Create `src/tract/operations/navigation.py`:**

This module contains the pure logic for reset and checkout operations. It takes repository objects as parameters (no direct DB access).

```python
"""Navigation operations: reset, checkout, resolve_commit."""
from __future__ import annotations
from typing import TYPE_CHECKING
from tract.exceptions import CommitNotFoundError, DetachedHeadError, AmbiguousPrefixError

if TYPE_CHECKING:
    from tract.storage.repositories import CommitRepository, RefRepository
```

Functions:

`resolve_commit(ref_or_prefix: str, tract_id: str, commit_repo, ref_repo) -> str`:
- If ref_or_prefix == "-": look up PREV_HEAD ref. If not set, raise TraceError("No previous position. PREV_HEAD not set.")
- If ref_or_prefix is a branch name (check ref_repo.get_branch()): return its commit hash
- If ref_or_prefix is a full 64-char hex hash: look up directly via commit_repo.get()
- Otherwise treat as prefix: call commit_repo.get_by_prefix(ref_or_prefix, tract_id=tract_id)
- If no match found: raise CommitNotFoundError(ref_or_prefix)
- Return the resolved commit hash

`reset(target_hash: str, mode: str, tract_id: str, ref_repo) -> str`:
- mode must be "soft" or "hard". Raise ValueError for anything else.
- Get current HEAD hash. If None, raise TraceError("No commits to reset from")
- Save current HEAD as ORIG_HEAD: ref_repo.set_ref(tract_id, "ORIG_HEAD", current_head)
- Save current HEAD as PREV_HEAD: ref_repo.set_ref(tract_id, "PREV_HEAD", current_head)
- For "soft": move HEAD to target (update the branch ref via ref_repo.update_head, or if detached, just update HEAD's commit_hash)
- For "hard": same as soft (commits stay in DB but become unreachable; GC is Phase 4)
- Actually both soft and hard move HEAD the same way in our model. The difference: soft stores ORIG_HEAD for recovery; hard also does but with --force required in CLI. At the SDK level, both are identical -- the distinction is at the CLI safety layer.
- Wait, re-reading CONTEXT.md: "Soft reset: moves HEAD back, stores ORIG_HEAD ref pointing to previous HEAD position." and "Hard reset: orphans forward commits (stay in DB, unreachable)." Both do the same thing in storage (move HEAD, orphan forward). The semantic difference is intent: soft is "I might want to come back" and hard is "I'm discarding." Both store ORIG_HEAD. The CLI requires --force for hard.
- Implementation: both modes store ORIG_HEAD, update PREV_HEAD, and move HEAD to target via update_head(). Return the target_hash.

`checkout(target: str, tract_id: str, commit_repo, ref_repo) -> tuple[str, bool]`:
- Resolve target: if it's a branch name (ref_repo.get_branch returns non-None), attach HEAD to that branch. Return (commit_hash, False) where False=not detached.
- If target is a commit hash (or prefix-resolved to one): detach HEAD to that commit. Update PREV_HEAD before moving HEAD. Return (commit_hash, True) where True=detached.
- Returns (resolved_commit_hash, is_detached).

**3. Extend `Tract` class in `src/tract/tract.py`:**

Add imports:
```python
from tract.operations.navigation import (
    resolve_commit as _resolve_commit,
    reset as _reset,
    checkout as _checkout,
)
```

Add public methods:

```python
def resolve_commit(self, ref_or_prefix: str) -> str:
    """Resolve a commit reference (hash, prefix, branch name, or '-') to a full hash."""
    return _resolve_commit(
        ref_or_prefix, self._tract_id,
        self._commit_repo, self._ref_repo,
    )

def reset(self, target: str, *, mode: str = "soft") -> str:
    """Reset HEAD to a previous commit.

    Args:
        target: Commit hash, prefix, or branch name.
        mode: "soft" (stores ORIG_HEAD for recovery) or "hard" (same storage effect, semantic intent to discard).

    Returns:
        The resolved target commit hash.
    """
    resolved = self.resolve_commit(target)
    result = _reset(resolved, mode, self._tract_id, self._ref_repo)
    self._session.commit()
    # Clear compile cache (HEAD changed)
    self._cache_clear()
    return result

def checkout(self, target: str) -> str:
    """Checkout a commit or branch.

    If target is a branch name: attach HEAD to that branch.
    If target is a commit hash/prefix: detach HEAD at that commit.
    If target is "-": return to PREV_HEAD position.

    Returns:
        The resolved commit hash.
    """
    # Resolve "-" first
    if target == "-":
        prev = self._ref_repo.get_ref(self._tract_id, "PREV_HEAD")
        if prev is None:
            from tract.exceptions import TraceError
            raise TraceError("No previous position to return to. PREV_HEAD not set.")
        target = prev  # Now target is a commit hash

    commit_hash, is_detached = _checkout(
        target, self._tract_id,
        self._commit_repo, self._ref_repo,
    )
    self._session.commit()
    # Clear compile cache (HEAD changed) -- but LRU may have a hit for the new HEAD
    # Don't clear: the LRU cache is keyed by head_hash, so switching HEAD may get a cache hit
    # Actually, we should NOT clear cache here -- the whole point of LRU is checkout cache hits
    return commit_hash
```

**4. Guard commit() against detached HEAD in `src/tract/tract.py`:**

At the top of `Tract.commit()`, add:
```python
if self._ref_repo.is_detached(self._tract_id):
    from tract.exceptions import DetachedHeadError
    raise DetachedHeadError()
```

**5. Guard commit() against detached HEAD in `src/tract/engine/commit.py`:**

Actually, the guard should be in `Tract.commit()` only (not CommitEngine), because CommitEngine is a lower-level component and detached HEAD is a Tract-level concept. CommitEngine's `create_commit()` doesn't know about symbolic refs.

**6. Update `src/tract/__init__.py`:**

Add exports for new exceptions:
```python
from tract.exceptions import (
    ...,
    DetachedHeadError,
    AmbiguousPrefixError,
)
```
Add to `__all__` list.

**7. Create `tests/test_navigation.py`** with comprehensive tests:

Test categories:
- **Symbolic ref resolution**: After first commit, HEAD is symbolic -> refs/heads/main. get_head() resolves through symbolic ref. get_current_branch() returns "main". is_detached() returns False.
- **Prefix matching**: Create multiple commits, look up by 7-char prefix. Test minimum 4-char requirement. Test AmbiguousPrefixError (hard to trigger with SHA-256, so may need to mock or just verify the code path with a test that checks the method signature).
- **resolve_commit()**: Full hash, prefix, branch name, "-" shortcut. CommitNotFoundError for invalid refs.
- **reset (soft)**: Creates tract with 3 commits. Reset to first commit. HEAD now points to first. ORIG_HEAD stores previous HEAD. Commits are still in DB.
- **reset (hard)**: Same behavior as soft at SDK level. (CLI adds --force requirement.)
- **checkout (commit hash)**: Detaches HEAD. is_detached() returns True. Attempting commit raises DetachedHeadError.
- **checkout (branch name)**: Re-attaches HEAD. is_detached() returns False. Can commit again.
- **checkout -**: After checkout to detached, checkout - returns to previous position via PREV_HEAD.
- **LRU cache hit on checkout**: Create tract, commit A, commit B (HEAD=B). Compile (caches B). Reset to A, compile (caches A). Checkout B -- compile should be a cache hit (no full recompile).
- **267 existing tests still pass**: No regressions.

Use `Tract.open(":memory:")` for all tests. Follow existing test conventions from test_tract.py.

Aim for ~25-35 tests covering all navigation paths.
  </action>
  <verify>
Run `python -m pytest tests/ -x -q` -- all tests pass (267 existing + new navigation tests). Specifically verify:
1. `python -m pytest tests/test_navigation.py -v` -- all new tests pass
2. `python -m pytest tests/test_tract.py -v` -- all 267 existing tests pass (no regressions from symbolic ref migration)
  </verify>
  <done>
operations/ package exists with navigation.py. Tract has reset(), checkout(), resolve_commit() methods. Detached HEAD blocks commits with DetachedHeadError. Symbolic refs resolve HEAD through branch refs. PREV_HEAD and ORIG_HEAD refs managed correctly. Prefix matching works for commit lookup. All tests pass including 267 existing + ~25-35 new navigation tests.
  </done>
</task>

</tasks>

<verification>
1. All 267 existing tests pass (zero regressions from symbolic ref migration)
2. New navigation tests pass (~25-35 tests)
3. `Tract.reset("soft")` moves HEAD and stores ORIG_HEAD
4. `Tract.checkout(commit_hash)` detaches HEAD; subsequent commit() raises DetachedHeadError
5. `Tract.checkout("main")` re-attaches HEAD; commit() works again
6. `Tract.checkout("-")` returns to PREV_HEAD
7. `Tract.resolve_commit(prefix)` finds commit by 4+ char prefix
8. LRU cache survives checkout/reset (no unnecessary cache clears)
</verification>

<success_criteria>
- Storage layer has symbolic ref infrastructure (attach_head, detach_head, is_detached, get_current_branch)
- Storage layer has prefix matching (get_by_prefix with AmbiguousPrefixError)
- Navigation operations (reset, checkout) work through Tract facade
- Detached HEAD prevents commits
- PREV_HEAD and ORIG_HEAD refs track position history
- All 267 + ~30 new tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-linear-history-cli/02-01-SUMMARY.md`
</output>
