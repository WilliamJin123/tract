---
phase: 11-unified-llm-config-query
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/tract/models/config.py
  - src/tract/__init__.py
  - src/tract/models/__init__.py
  - src/tract/tract.py
  - src/tract/models/commit.py
  - src/tract/protocols.py
  - src/tract/engine/commit.py
  - src/tract/engine/cache.py
  - src/tract/engine/compiler.py
  - src/tract/storage/repositories.py
  - src/tract/storage/sqlite.py
  - src/tract/operations/rebase.py
  - src/tract/operations/merge.py
  - src/tract/operations/compression.py
  - src/tract/operations/diff.py
  - src/tract/operations/session_ops.py
  - src/tract/operations/spawn.py
  - src/tract/operations/__init__.py
  - src/tract/toolkit/definitions.py
  - src/tract/llm/protocols.py
  - tests/test_operation_config.py
autonomous: true

must_haves:
  truths:
    - "LLMConfig frozen dataclass exists with 9 typed Optional fields plus extra dict escape hatch"
    - "LLMOperationConfig is fully removed -- no references in source or tests"
    - "CommitInfo.generation_config returns Optional[LLMConfig] (not dict)"
    - "ChatResponse.generation_config returns LLMConfig (not dict)"
    - "CompiledContext.generation_configs returns list[LLMConfig | None] (not list[dict])"
    - "Storage layer still uses JSON dicts internally -- conversion at boundaries only"
    - "All existing tests pass after migration"
    - "configure_operations() accepts LLMConfig instead of LLMOperationConfig"
    - "Tract.open() operation_configs parameter accepts dict[str, LLMConfig]"
  artifacts:
    - path: "src/tract/models/config.py"
      provides: "LLMConfig frozen dataclass with from_dict/to_dict/non_none_fields"
      contains: "class LLMConfig"
    - path: "src/tract/__init__.py"
      provides: "LLMConfig export, LLMOperationConfig removed"
      contains: "LLMConfig"
    - path: "src/tract/protocols.py"
      provides: "ChatResponse.generation_config: LLMConfig, CompiledContext.generation_configs: list[LLMConfig | None]"
      contains: "LLMConfig"
    - path: "src/tract/models/commit.py"
      provides: "CommitInfo.generation_config: Optional[LLMConfig]"
      contains: "LLMConfig"
    - path: "tests/test_operation_config.py"
      provides: "Renamed to test_llm_config.py equivalent -- all LLMOperationConfig -> LLMConfig"
      contains: "LLMConfig"
  key_links:
    - from: "src/tract/engine/commit.py"
      to: "src/tract/models/commit.py"
      via: "_row_to_info converts dict -> LLMConfig at boundary"
      pattern: "LLMConfig\\.from_dict"
    - from: "src/tract/engine/cache.py"
      to: "src/tract/protocols.py"
      via: "to_compiled converts tuple[dict,...] -> list[LLMConfig | None]"
      pattern: "LLMConfig\\.from_dict"
    - from: "src/tract/tract.py"
      to: "src/tract/models/config.py"
      via: "configure_operations validates LLMConfig type"
      pattern: "isinstance.*LLMConfig"
---

<objective>
Replace LLMOperationConfig with LLMConfig and migrate all references across the codebase.

Purpose: Unify the LLM configuration type so a single LLMConfig class with full hyperparameter coverage is used everywhere -- operation defaults, call-time overrides, and commit-level storage. This eliminates the gap between the limited 4-field LLMOperationConfig (runtime-only) and the untyped dict generation_config (persisted), replacing both with one typed class.

Output: LLMConfig frozen dataclass in models/config.py, all ~20 files migrated, all existing tests passing with LLMConfig instead of LLMOperationConfig.
</objective>

<execution_context>
@C:\Users\jinwi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jinwi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-unified-llm-config-query/11-RESEARCH.md
@src/tract/models/config.py
@src/tract/protocols.py
@src/tract/models/commit.py
@src/tract/engine/commit.py
@src/tract/engine/cache.py
@src/tract/engine/compiler.py
@src/tract/tract.py
@src/tract/__init__.py
@src/tract/storage/sqlite.py
@src/tract/storage/repositories.py
@tests/test_operation_config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define LLMConfig and migrate models/protocols layer</name>
  <files>
    src/tract/models/config.py
    src/tract/models/commit.py
    src/tract/models/__init__.py
    src/tract/protocols.py
    src/tract/__init__.py
    src/tract/engine/commit.py
    src/tract/engine/cache.py
    src/tract/engine/compiler.py
  </files>
  <action>
**Step 1: Replace LLMOperationConfig with LLMConfig in `src/tract/models/config.py`.**

Remove the `LLMOperationConfig` class entirely. Replace it with `LLMConfig` frozen dataclass:

```python
import types
from dataclasses import dataclass, fields as dc_fields

@dataclass(frozen=True)
class LLMConfig:
    """Fully-typed LLM configuration.

    All fields are Optional -- None means 'not set / inherit from higher level.'
    Used everywhere: operation defaults, call-time overrides, commit-level storage.
    """
    model: str | None = None
    temperature: float | None = None
    top_p: float | None = None
    max_tokens: int | None = None
    stop_sequences: tuple[str, ...] | None = None
    frequency_penalty: float | None = None
    presence_penalty: float | None = None
    top_k: int | None = None
    seed: int | None = None
    extra: dict | None = None

    def __post_init__(self) -> None:
        if self.extra is not None:
            object.__setattr__(self, "extra", types.MappingProxyType(dict(self.extra)))
        if self.stop_sequences is not None and not isinstance(self.stop_sequences, tuple):
            object.__setattr__(self, "stop_sequences", tuple(self.stop_sequences))

    def __hash__(self) -> int:
        extra_hashable = tuple(sorted(self.extra.items())) if self.extra else ()
        return hash((
            self.model, self.temperature, self.top_p, self.max_tokens,
            self.stop_sequences, self.frequency_penalty, self.presence_penalty,
            self.top_k, self.seed, extra_hashable,
        ))

    @classmethod
    def from_dict(cls, d: dict | None) -> LLMConfig | None:
        if d is None:
            return None
        known = {f.name for f in dc_fields(cls)} - {"extra"}
        known_kwargs = {}
        extra_kwargs = {}
        for k, v in d.items():
            if k in known:
                known_kwargs[k] = v
            else:
                extra_kwargs[k] = v
        if "stop_sequences" in known_kwargs and isinstance(known_kwargs["stop_sequences"], list):
            known_kwargs["stop_sequences"] = tuple(known_kwargs["stop_sequences"])
        return cls(**known_kwargs, extra=extra_kwargs if extra_kwargs else None)

    def to_dict(self) -> dict:
        result = {}
        for f in dc_fields(self):
            if f.name == "extra":
                continue
            val = getattr(self, f.name)
            if val is not None:
                if isinstance(val, tuple):
                    val = list(val)
                result[f.name] = val
        if self.extra:
            result.update(dict(self.extra))
        return result

    def non_none_fields(self) -> dict:
        result = {}
        for f in dc_fields(self):
            if f.name == "extra":
                continue
            val = getattr(self, f.name)
            if val is not None:
                result[f.name] = val
        return result
```

Update the module docstring to mention LLMConfig instead of LLMOperationConfig.

**Step 2: Update `src/tract/models/commit.py`.**

Change `CommitInfo.generation_config` type from `Optional[dict]` to `Optional[LLMConfig]`. Import LLMConfig. Since CommitInfo is a Pydantic BaseModel and LLMConfig is a frozen dataclass, Pydantic v2 handles dataclass fields. BUT we need a field validator to handle dict input from deserialization:

```python
from tract.models.config import LLMConfig

class CommitInfo(BaseModel):
    # ... existing fields ...
    generation_config: Optional[LLMConfig] = None

    @field_validator("generation_config", mode="before")
    @classmethod
    def _coerce_generation_config(cls, v):
        if isinstance(v, dict):
            return LLMConfig.from_dict(v)
        return v
```

Import `field_validator` from pydantic. This ensures that when CommitInfo is constructed with a dict (which happens in _row_to_info and many other places), it auto-converts to LLMConfig.

**Step 3: Update `src/tract/protocols.py`.**

- Change `ChatResponse.generation_config` type from `dict` to `LLMConfig`. Add import under TYPE_CHECKING or directly (since LLMConfig is a dataclass, no circular import risk -- but check; if there IS a risk, use TYPE_CHECKING + string annotation).
- Change `CompiledContext.generation_configs` from `list[dict]` to `list[LLMConfig | None]` with `field(default_factory=list)`.
- `CompileSnapshot.generation_configs` stays as `tuple[dict, ...]` -- the cache stores dicts internally for performance. Conversion to LLMConfig happens in `CacheManager.to_compiled()`.

Import LLMConfig:
```python
from tract.models.config import LLMConfig
```

**Step 4: Update `src/tract/engine/commit.py`.**

In `_row_to_info()`, the `generation_config=row.generation_config_json` assignment now goes into a Pydantic field that auto-coerces dict -> LLMConfig via the validator added in Step 2. No code change needed in _row_to_info itself.

In `create_commit()` and `create_merge_commit()`:
- The `generation_config` parameter type stays as `dict | None` (this is what the internal engine receives from the facade after `to_dict()` conversion).
- The `CommitRow.generation_config_json` stays as dict (SQLAlchemy JSON column).
- The `CommitInfo(generation_config=generation_config)` construction will auto-coerce via the Pydantic validator.

No change needed in create_commit/create_merge_commit signatures -- they already pass dicts and the Pydantic validator handles conversion.

**Step 5: Update `src/tract/engine/cache.py`.**

In `CacheManager.to_compiled()`:
- Currently: `generation_configs=[dict(c) for c in snapshot.generation_configs]`
- Change to: `generation_configs=[LLMConfig.from_dict(c) if c else None for c in snapshot.generation_configs]`
- Import LLMConfig at top.

In `build_snapshot()`:
- Currently: `generation_configs=tuple(dict(c) for c in result.generation_configs)`
- Change to: `generation_configs=tuple(c.to_dict() if c is not None else {} for c in result.generation_configs)`
- This converts from LLMConfig (CompiledContext) back to dict (CompileSnapshot internal).

In `extend_for_append()`:
- `new_config = dict(commit_row.generation_config_json or {})` -- stays as dict (internal cache format).

In `patch_for_edit()`:
- `new_configs[target_idx] = dict(edit_row.generation_config_json)` -- stays as dict.

**Step 6: Update `src/tract/engine/compiler.py`.**

In `compile()` method, the `generation_configs: list[dict]` local variable construction stays as dict. But the return value `CompiledContext(generation_configs=generation_configs)` now feeds into `list[LLMConfig | None]`. We need to convert:
- Change the generation_configs construction to produce `list[LLMConfig | None]`:
```python
generation_configs: list[LLMConfig | None] = []
for c in effective_commits:
    edit_commit = edit_map.get(c.commit_hash)
    if edit_commit is not None and edit_commit.generation_config_json is not None:
        config = LLMConfig.from_dict(edit_commit.generation_config_json)
    else:
        config = LLMConfig.from_dict(c.generation_config_json) if c.generation_config_json else None
    generation_configs.append(config)
```
Import LLMConfig at top (under TYPE_CHECKING is fine if needed, but since we use it at runtime, import directly).

**Step 7: Update `src/tract/__init__.py` and `src/tract/models/__init__.py`.**

In `src/tract/__init__.py`:
- Change `from tract.models.config import TractConfig, TokenBudgetConfig, BudgetAction, LLMOperationConfig` to `from tract.models.config import TractConfig, TokenBudgetConfig, BudgetAction, LLMConfig`
- In `__all__`, replace `"LLMOperationConfig"` with `"LLMConfig"`

In `src/tract/models/__init__.py`:
- Add `LLMConfig` to imports and `__all__` if it should be re-exported (follow pattern of other config exports).

  </action>
  <verify>
Run `python -c "from tract import LLMConfig; c = LLMConfig(model='gpt-4o', temperature=0.7); print(c); print(c.to_dict()); print(LLMConfig.from_dict(c.to_dict()) == c)"` -- should print True.

Run `python -c "from tract import LLMConfig; c = LLMConfig(extra={'provider_key': 'val'}); print(c.extra['provider_key']); print(c.to_dict())"` -- should show MappingProxyType behavior.

Run `python -c "from tract import LLMConfig; import tract; assert not hasattr(tract, 'LLMOperationConfig')"` -- should not raise.

Run `python -c "from tract.models.commit import CommitInfo; ci = CommitInfo(commit_hash='a', tract_id='b', content_hash='c', content_type='d', operation='append', token_count=0, created_at='2024-01-01T00:00:00', generation_config={'model': 'gpt-4o', 'temperature': 0.5}); print(type(ci.generation_config)); print(ci.generation_config.model)"` -- should print LLMConfig and gpt-4o.
  </verify>
  <done>
LLMConfig exists with all 9 typed fields + extra. LLMOperationConfig is removed from config.py. CommitInfo.generation_config auto-coerces dict to LLMConfig. ChatResponse.generation_config is LLMConfig. CompiledContext.generation_configs is list[LLMConfig | None]. Cache internal format stays as dict. All model/protocol layer types are consistent.
  </done>
</task>

<task type="auto">
  <name>Task 2: Migrate facade, operations, and all tests</name>
  <files>
    src/tract/tract.py
    src/tract/operations/rebase.py
    src/tract/operations/merge.py
    src/tract/operations/compression.py
    src/tract/operations/diff.py
    src/tract/operations/session_ops.py
    src/tract/operations/spawn.py
    src/tract/operations/__init__.py
    src/tract/toolkit/definitions.py
    src/tract/llm/protocols.py
    src/tract/storage/repositories.py
    src/tract/storage/sqlite.py
    tests/test_operation_config.py
  </files>
  <action>
**Step 1: Update `src/tract/tract.py` -- imports and type annotations.**

- Change `from tract.models.config import LLMOperationConfig, TractConfig` to `from tract.models.config import LLMConfig, TractConfig`
- `self._operation_configs: dict[str, LLMOperationConfig] = {}` -> `self._operation_configs: dict[str, LLMConfig] = {}`
- `Tract.open()` parameter `operation_configs: dict[str, LLMOperationConfig] | None = None` -> `operation_configs: dict[str, LLMConfig] | None = None`
- All docstring references to `LLMOperationConfig` -> `LLMConfig`

**Step 2: Update `_resolve_llm_config` in tract.py.**

Currently it has explicit `model`, `temperature`, `max_tokens`, `**kwargs` parameters and manually chains them. Rewrite to use LLMConfig merging:

```python
def _resolve_llm_config(
    self,
    operation: str,
    *,
    model: str | None = None,
    temperature: float | None = None,
    max_tokens: int | None = None,
    **kwargs: object,
) -> dict:
    """Resolve effective LLM config: call-level > operation-level > tract-level.

    Returns a dict of kwargs to pass to llm_client.chat().
    """
    op_config = self._operation_configs.get(operation)

    resolved: dict = {}

    # Model: call > operation > tract default
    if model is not None:
        resolved["model"] = model
    elif op_config is not None and op_config.model is not None:
        resolved["model"] = op_config.model
    elif self._default_model is not None:
        resolved["model"] = self._default_model

    # Temperature: call > operation
    if temperature is not None:
        resolved["temperature"] = temperature
    elif op_config is not None and op_config.temperature is not None:
        resolved["temperature"] = op_config.temperature

    # Max tokens: call > operation
    if max_tokens is not None:
        resolved["max_tokens"] = max_tokens
    elif op_config is not None and op_config.max_tokens is not None:
        resolved["max_tokens"] = op_config.max_tokens

    # New typed fields from LLMConfig: top_p, frequency_penalty, presence_penalty, top_k, seed, stop_sequences
    if op_config is not None:
        for field_name in ("top_p", "frequency_penalty", "presence_penalty", "top_k", "seed", "stop_sequences"):
            val = getattr(op_config, field_name, None)
            if val is not None and field_name not in kwargs:
                if isinstance(val, tuple):
                    resolved[field_name] = list(val)  # LLM clients expect list
                else:
                    resolved[field_name] = val

    # Extra from operation config (call kwargs override)
    if op_config is not None and op_config.extra:
        resolved.update(dict(op_config.extra))
    resolved.update(kwargs)

    return resolved
```

**Step 3: Update `configure_operations` in tract.py.**

- Change isinstance check from `LLMOperationConfig` to `LLMConfig`
- Update error message: `"Expected LLMConfig for '{name}'"`
- Update property return type: `dict[str, LLMConfig]`
- Update all docstring references

**Step 4: Update `_build_generation_config` in tract.py.**

This method builds a dict from the LLM response. The return type stays as `dict` since it feeds into `CommitEngine.create_commit(generation_config=...)` which stores it as JSON. The Pydantic validator on CommitInfo auto-coerces when reading back.

No change needed here -- it already returns dict.

**Step 5: Update `query_by_config` in tract.py.**

Keep the existing single-field signature for backward compatibility (Plan 02 will add the multi-field overload). No change needed in this plan.

**Step 6: Update operations files.**

All these files construct CommitInfo objects and pass `generation_config=row.generation_config_json`. The Pydantic validator on CommitInfo auto-coerces dict -> LLMConfig, so most need NO code changes. But verify each:

- `src/tract/operations/rebase.py`: Lines 100-102 and 231-233 pass `generation_config=dict(original_row.generation_config_json) if original_row.generation_config_json else None`. This stays as-is -- Pydantic auto-coerces.
- `src/tract/operations/merge.py`: `generation_config` param and handling. Passes dict -- auto-coerced.
- `src/tract/operations/compression.py`: `generation_config=row.generation_config_json`. Auto-coerced.
- `src/tract/operations/diff.py`: `_compute_generation_config_changes` compares dicts -- this needs updating. The function receives `configs_a` and `configs_b` which are now `list[LLMConfig | None]` from CompiledContext. Update to work with LLMConfig by calling `.to_dict()` on them, OR update comparison logic to handle LLMConfig objects. Simplest: convert to dicts for comparison since diff is about field-level changes.
- `src/tract/operations/session_ops.py`: `generation_config=row.generation_config_json`. Auto-coerced.
- `src/tract/operations/spawn.py`: `generation_config=commit_row.generation_config_json`. Auto-coerced.
- `src/tract/operations/__init__.py`: `generation_config=row.generation_config_json`. Auto-coerced.

For `diff.py`, update `_compute_generation_config_changes` to handle LLMConfig inputs:
```python
def _compute_generation_config_changes(
    configs_a: list[LLMConfig | None], configs_b: list[LLMConfig | None]
) -> dict[str, tuple[Any, Any]]:
    # Convert to flat dicts for comparison
    dicts_a = [c.to_dict() if c is not None else {} for c in configs_a]
    dicts_b = [c.to_dict() if c is not None else {} for c in configs_b]
    # ... rest of comparison logic using dicts_a, dicts_b
```

- `src/tract/toolkit/definitions.py`: Check if it references generation_config as dict -- likely just passes through, no change needed.
- `src/tract/llm/protocols.py`: Check if it has generation_config type hints -- update if so.

**Step 7: Update tests.**

In `tests/test_operation_config.py`:
- Global replace `LLMOperationConfig` with `LLMConfig` in all imports, class names, instances, assertions, and docstrings.
- `extra_kwargs` field references become `extra` field references.
- Rename test class `TestLLMOperationConfig` to `TestLLMConfig`.
- Update the test `test_create_with_values` to include new fields (top_p, frequency_penalty, etc.) -- add a test.
- Update `test_create_with_defaults` to check all 10 fields are None.
- The `test_resolve_extra_kwargs_merged` test uses `extra_kwargs={"top_p": 0.9, "seed": 42}`. Since `top_p` and `seed` are now first-class fields on LLMConfig, update this test:
  - Change to `LLMConfig(top_p=0.9, seed=42)` (first-class) or `LLMConfig(extra={"custom_param": "val"})` (for extra testing).
  - The resolution chain already picks up top_p and seed as typed fields.
- All `TypeError` match strings: update `"Expected LLMOperationConfig"` to `"Expected LLMConfig"`.

**Step 8: Run full test suite.**

Run `python -m pytest tests/ -x` to verify all existing tests pass. Fix any failures caused by the migration.

**IMPORTANT ANTI-PATTERNS TO AVOID:**
- Do NOT change SQLite schema (generation_config_json column stays as JSON dict).
- Do NOT change CompileSnapshot.generation_configs type (stays tuple[dict, ...]).
- Do NOT break backward compatibility of commit() accepting dict for generation_config param.
- Do NOT change _row_to_info signature -- the Pydantic validator handles coercion.
  </action>
  <verify>
Run `python -m pytest tests/ -x -q` -- all tests pass (should be ~983 tests).

Run `python -m pytest tests/test_operation_config.py -v` -- all LLMConfig tests pass (verify no LLMOperationConfig references remain).

Run `python -c "import ast, sys; [sys.exit(1) for line in open('src/tract/tract.py') if 'LLMOperationConfig' in line]"` -- no references remain in tract.py.

Grep for LLMOperationConfig across src/ and tests/ -- zero hits.
  </verify>
  <done>
All ~20 files migrated from LLMOperationConfig to LLMConfig. Zero references to LLMOperationConfig remain in src/ or tests/. The three-level resolution chain (call > operation > tract) works with LLMConfig. All existing tests pass. The full hyperparameter set (9 fields + extra) is available on LLMConfig.
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/ -x -q` -- all ~983 tests pass
2. `grep -r "LLMOperationConfig" src/ tests/` -- zero matches
3. `python -c "from tract import LLMConfig; c = LLMConfig(model='gpt-4o', temperature=0.7, top_p=0.9, seed=42); assert c.to_dict() == {'model': 'gpt-4o', 'temperature': 0.7, 'top_p': 0.9, 'seed': 42}; print('OK')"` -- prints OK
4. `python -c "from tract import LLMConfig; d = {'model': 'gpt-4o', 'temperature': 0.5, 'custom_provider_key': 'abc'}; c = LLMConfig.from_dict(d); assert c.model == 'gpt-4o'; assert c.extra['custom_provider_key'] == 'abc'; assert LLMConfig.from_dict(c.to_dict()) == c; print('Round-trip OK')"` -- prints Round-trip OK
5. `python -c "from tract.models.commit import CommitInfo; ci = CommitInfo(commit_hash='a', tract_id='b', content_hash='c', content_type='d', operation='append', token_count=0, created_at='2024-01-01', generation_config={'model': 'x'}); assert ci.generation_config.model == 'x'; print('Pydantic coerce OK')"` -- prints OK
</verification>

<success_criteria>
- LLMConfig frozen dataclass with all 9 typed fields + extra dict exists and is exported
- LLMOperationConfig is fully removed from the codebase (zero grep matches in src/ and tests/)
- CommitInfo.generation_config auto-coerces dict input to LLMConfig via Pydantic validator
- ChatResponse.generation_config type is LLMConfig
- CompiledContext.generation_configs type is list[LLMConfig | None]
- CompileSnapshot internal cache format still uses tuple[dict, ...] (not LLMConfig)
- All ~983 existing tests pass
- configure_operations() and Tract.open() accept LLMConfig
</success_criteria>

<output>
After completion, create `.planning/phases/11-unified-llm-config-query/11-01-SUMMARY.md`
</output>
