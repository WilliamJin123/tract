---
phase: 11-unified-llm-config-query
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - src/tract/storage/repositories.py
  - src/tract/storage/sqlite.py
  - src/tract/tract.py
  - tests/test_operation_config.py
  - tests/test_tract.py
  - cookbook/01_foundations/first_conversation.py
  - cookbook/01_foundations/atomic_batch.py
  - cookbook/01_foundations/token_budget_guardrail.py
autonomous: true

must_haves:
  truths:
    - "query_by_config supports multiple field conditions in a single call with AND semantics"
    - "query_by_config supports the IN operator for set membership queries"
    - "Users can query by an entire LLMConfig object to find commits matching all its non-None fields"
    - "Existing single-field query_by_config(field, op, value) still works unchanged"
    - "All 3 Tier 1 cookbook examples use LLMConfig typed access instead of .get()"
  artifacts:
    - path: "src/tract/storage/sqlite.py"
      provides: "get_by_config_multi with AND + IN support"
      contains: "get_by_config_multi"
    - path: "src/tract/storage/repositories.py"
      provides: "CommitRepository.get_by_config_multi abstract method"
      contains: "get_by_config_multi"
    - path: "src/tract/tract.py"
      provides: "query_by_config overloaded: single-field, multi-field, whole-config"
      contains: "LLMConfig"
    - path: "cookbook/01_foundations/first_conversation.py"
      provides: "Typed LLMConfig access (.model instead of .get('model'))"
      contains: ".model"
    - path: "cookbook/01_foundations/atomic_batch.py"
      provides: "Typed LLMConfig access"
      contains: ".model"
  key_links:
    - from: "src/tract/tract.py"
      to: "src/tract/storage/sqlite.py"
      via: "query_by_config dispatches to get_by_config_multi"
      pattern: "get_by_config_multi"
    - from: "src/tract/storage/sqlite.py"
      to: "SQLite json_extract"
      via: "IN operator via .in_() on extracted column"
      pattern: "\\.in_\\("
---

<objective>
Add rich query_by_config support (multi-field AND, IN operator, whole-config matching) and update Tier 1 cookbook examples.

Purpose: Users can query commits by complex config conditions (e.g., "model is gpt-4o AND temperature > 0.5") or by passing an LLMConfig object to match all its fields. The cookbook examples demonstrate typed access patterns, showing users the improved DX.

Output: Enhanced query_by_config with three calling patterns, new repository method, comprehensive tests, updated cookbooks.
</objective>

<execution_context>
@C:\Users\jinwi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jinwi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-unified-llm-config-query/11-RESEARCH.md
@.planning/phases/11-unified-llm-config-query/11-01-SUMMARY.md
@src/tract/storage/sqlite.py
@src/tract/storage/repositories.py
@src/tract/tract.py
@src/tract/models/config.py
@cookbook/01_foundations/first_conversation.py
@cookbook/01_foundations/atomic_batch.py
@cookbook/01_foundations/token_budget_guardrail.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add multi-field AND + IN query support at storage and facade layer</name>
  <files>
    src/tract/storage/repositories.py
    src/tract/storage/sqlite.py
    src/tract/tract.py
  </files>
  <action>
**Step 1: Add `get_by_config_multi` to `CommitRepository` ABC in `src/tract/storage/repositories.py`.**

Add a new abstract method after `get_by_config`:

```python
@abstractmethod
def get_by_config_multi(
    self, tract_id: str, conditions: list[tuple[str, str, object]]
) -> Sequence[CommitRow]:
    """Get commits matching multiple generation config conditions (AND semantics).

    Args:
        tract_id: Tract identifier to scope the query.
        conditions: List of (json_path, operator, value) tuples.
            Operators: "=", "!=", ">", "<", ">=", "<=", "in".
            The "in" operator expects value to be a list/tuple.
        All conditions are combined with AND.

    Returns:
        Matching commits ordered by created_at ascending.
    """
    ...
```

**Step 2: Implement `get_by_config_multi` in `SqliteCommitRepository` in `src/tract/storage/sqlite.py`.**

Add after the existing `get_by_config` method:

```python
def get_by_config_multi(
    self, tract_id: str, conditions: list[tuple[str, str, object]]
) -> Sequence[CommitRow]:
    where_clauses = [CommitRow.tract_id == tract_id]
    ops = {
        "=": lambda e, v: e == v,
        "!=": lambda e, v: e != v,
        ">": lambda e, v: e > v,
        "<": lambda e, v: e < v,
        ">=": lambda e, v: e >= v,
        "<=": lambda e, v: e <= v,
        "in": lambda e, v: e.in_(v),
    }
    for json_path, operator, value in conditions:
        if operator not in ops:
            raise ValueError(
                f"Unsupported operator: {operator}. "
                f"Use one of: {list(ops.keys())}"
            )
        extracted = func.json_extract(
            CommitRow.generation_config_json, f'$.{json_path}'
        )
        where_clauses.append(ops[operator](extracted, value))
    stmt = (
        select(CommitRow)
        .where(and_(*where_clauses))
        .order_by(CommitRow.created_at)
    )
    return list(self._session.execute(stmt).scalars().all())
```

Also refactor existing `get_by_config` to delegate to `get_by_config_multi`:

```python
def get_by_config(
    self, tract_id: str, json_path: str, operator: str, value: object
) -> Sequence[CommitRow]:
    return self.get_by_config_multi(tract_id, [(json_path, operator, value)])
```

This keeps backward compatibility while removing code duplication.

**Step 3: Upgrade `query_by_config` in `src/tract/tract.py`.**

Replace the current single-field signature with an overloaded method supporting three calling patterns:

```python
def query_by_config(
    self,
    field_or_config: str | LLMConfig | None = None,
    operator: str | None = None,
    value: object = None,
    *,
    conditions: list[tuple[str, str, object]] | None = None,
) -> list[CommitInfo]:
    """Query commits by generation config values.

    Supports three calling patterns:

    1. **Single field** (backward compatible)::

        t.query_by_config("model", "=", "gpt-4o")
        t.query_by_config("temperature", ">", 0.5)

    2. **Multi-field AND** (new)::

        t.query_by_config(conditions=[
            ("model", "=", "gpt-4o"),
            ("temperature", ">", 0.5),
        ])

    3. **Whole-config match** (new)::

        t.query_by_config(LLMConfig(model="gpt-4o", temperature=0.7))
        # Finds commits matching ALL non-None fields with "=" semantics

    The IN operator is supported for set membership::

        t.query_by_config(conditions=[("model", "in", ["gpt-4o", "gpt-4o-mini"])])

    Args:
        field_or_config: A field name (str) for single-field query, or
            an LLMConfig object for whole-config matching.
        operator: Comparison operator (single-field mode only).
        value: Value to compare against (single-field mode only).
        conditions: List of (field, operator, value) tuples for
            multi-field AND queries.

    Returns:
        List of CommitInfo matching the condition(s), ordered by created_at.
    """
    from tract.models.config import LLMConfig

    if isinstance(field_or_config, LLMConfig):
        # Whole-config match: convert non-None fields to AND conditions
        conds = []
        for k, v in field_or_config.non_none_fields().items():
            if isinstance(v, tuple):
                v = list(v)  # SQLite expects list for JSON arrays
            conds.append((k, "=", v))
        if not conds:
            return []
        rows = self._commit_repo.get_by_config_multi(self._tract_id, conds)
    elif conditions is not None:
        # Multi-field AND
        rows = self._commit_repo.get_by_config_multi(self._tract_id, conditions)
    elif isinstance(field_or_config, str) and operator is not None:
        # Single-field (backward compatible)
        rows = self._commit_repo.get_by_config_multi(
            self._tract_id, [(field_or_config, operator, value)]
        )
    else:
        raise TypeError(
            "query_by_config requires either: "
            "(field, operator, value), "
            "conditions=[...], "
            "or an LLMConfig object"
        )
    return [self._commit_engine._row_to_info(row) for row in rows]
```

Update the import at the top of tract.py: ensure `LLMConfig` is imported from `tract.models.config`.
  </action>
  <verify>
Run `python -c "
from tract import Tract, LLMConfig, DialogueContent
t = Tract.open()
# Create commits with different configs
t.commit(DialogueContent(role='user', text='q1'), generation_config={'model': 'gpt-4o', 'temperature': 0.5})
t.commit(DialogueContent(role='assistant', text='a1'), generation_config={'model': 'gpt-4o', 'temperature': 0.9})
t.commit(DialogueContent(role='user', text='q2'), generation_config={'model': 'gpt-3.5-turbo', 'temperature': 0.5})

# Single-field (backward compat)
r1 = t.query_by_config('model', '=', 'gpt-4o')
assert len(r1) == 2, f'Expected 2, got {len(r1)}'

# Multi-field AND
r2 = t.query_by_config(conditions=[('model', '=', 'gpt-4o'), ('temperature', '>', 0.7)])
assert len(r2) == 1, f'Expected 1, got {len(r2)}'

# IN operator
r3 = t.query_by_config(conditions=[('model', 'in', ['gpt-4o', 'gpt-3.5-turbo'])])
assert len(r3) == 3, f'Expected 3, got {len(r3)}'

# Whole-config match
r4 = t.query_by_config(LLMConfig(model='gpt-4o', temperature=0.5))
assert len(r4) == 1, f'Expected 1, got {len(r4)}'

print('All query patterns OK')
t.close()
"` -- prints "All query patterns OK"
  </verify>
  <done>
query_by_config supports all three calling patterns: single-field (backward compatible), multi-field AND with IN operator, and whole-config LLMConfig matching. Storage layer has get_by_config_multi with full operator support.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update Tier 1 cookbooks and add comprehensive tests</name>
  <files>
    cookbook/01_foundations/first_conversation.py
    cookbook/01_foundations/atomic_batch.py
    cookbook/01_foundations/token_budget_guardrail.py
    tests/test_operation_config.py
    tests/test_tract.py
  </files>
  <action>
**Step 1: Update `cookbook/01_foundations/first_conversation.py`.**

Line 54: Change `response.generation_config.get('model')` to `response.generation_config.model`

Since `response.generation_config` is now `LLMConfig` (not dict), use typed attribute access:
```python
print(f"Model used: {response.generation_config.model}")
```

**Step 2: Update `cookbook/01_foundations/atomic_batch.py`.**

Line 102: Change `entry.generation_config.get('model')` to typed access. Since `entry.generation_config` is now `Optional[LLMConfig]`, handle the None case:
```python
print(f"  {entry.commit_hash[:8]} | {entry.message} | model={entry.generation_config.model if entry.generation_config else None}")
```

Also line 71: `response.generation_config` is now an LLMConfig object. The print on line 71 (`Config captured: {response.generation_config}`) will show the dataclass repr, which is fine and more informative.

Also line 89-90: The config_str line accesses `entry.generation_config` which is now Optional[LLMConfig]. The truthiness check works the same (LLMConfig() with all None fields is truthy but empty). Update to use to_dict() for display or just let the dataclass repr work:
```python
if entry.generation_config:
    config_str = f" | config: {entry.generation_config.to_dict()}"
```

**Step 3: Update `cookbook/01_foundations/token_budget_guardrail.py`.**

This cookbook does NOT use `generation_config.get()` at all. No changes needed. BUT verify it still works correctly with the LLMConfig type change (response.generation_config is now LLMConfig).

**Step 4: Add comprehensive tests for new query patterns.**

Add new test functions to `tests/test_operation_config.py` (or `tests/test_tract.py` -- add to whichever already has query_by_config tests; check test_tract.py for existing query tests).

Add a new test class `TestQueryByConfig` with tests for:

```python
class TestQueryByConfigMultiField:
    """Tests for enhanced query_by_config with multi-field AND and IN support."""

    def _setup_tract_with_configs(self):
        """Create a tract with commits using different generation configs."""
        t = Tract.open()
        t.commit(
            DialogueContent(role="user", text="q1"),
            generation_config={"model": "gpt-4o", "temperature": 0.5},
        )
        t.commit(
            DialogueContent(role="assistant", text="a1"),
            generation_config={"model": "gpt-4o", "temperature": 0.9},
        )
        t.commit(
            DialogueContent(role="user", text="q2"),
            generation_config={"model": "gpt-3.5-turbo", "temperature": 0.5},
        )
        t.commit(
            DialogueContent(role="assistant", text="a2"),
            generation_config={"model": "gpt-4o-mini", "temperature": 0.7},
        )
        return t

    def test_single_field_backward_compat(self):
        """Original (field, op, value) signature still works."""
        t = self._setup_tract_with_configs()
        results = t.query_by_config("model", "=", "gpt-4o")
        assert len(results) == 2
        assert all(r.generation_config.model == "gpt-4o" for r in results)
        t.close()

    def test_multi_field_and(self):
        """Multiple conditions combined with AND."""
        t = self._setup_tract_with_configs()
        results = t.query_by_config(conditions=[
            ("model", "=", "gpt-4o"),
            ("temperature", ">", 0.7),
        ])
        assert len(results) == 1
        assert results[0].generation_config.model == "gpt-4o"
        assert results[0].generation_config.temperature == 0.9
        t.close()

    def test_in_operator(self):
        """IN operator for set membership."""
        t = self._setup_tract_with_configs()
        results = t.query_by_config(conditions=[
            ("model", "in", ["gpt-4o", "gpt-3.5-turbo"]),
        ])
        assert len(results) == 3
        t.close()

    def test_in_operator_combined_with_field(self):
        """IN operator combined with other conditions."""
        t = self._setup_tract_with_configs()
        results = t.query_by_config(conditions=[
            ("model", "in", ["gpt-4o", "gpt-4o-mini"]),
            ("temperature", ">=", 0.7),
        ])
        assert len(results) == 2  # gpt-4o@0.9 and gpt-4o-mini@0.7
        t.close()

    def test_whole_config_match(self):
        """LLMConfig object matches all non-None fields."""
        t = self._setup_tract_with_configs()
        results = t.query_by_config(LLMConfig(model="gpt-4o", temperature=0.5))
        assert len(results) == 1
        assert results[0].generation_config.model == "gpt-4o"
        assert results[0].generation_config.temperature == 0.5
        t.close()

    def test_whole_config_single_field(self):
        """LLMConfig with only one field set matches like single-field query."""
        t = self._setup_tract_with_configs()
        results = t.query_by_config(LLMConfig(model="gpt-4o"))
        assert len(results) == 2
        t.close()

    def test_whole_config_empty_returns_empty(self):
        """LLMConfig with all None fields returns empty list."""
        t = self._setup_tract_with_configs()
        results = t.query_by_config(LLMConfig())
        assert len(results) == 0
        t.close()

    def test_no_matches(self):
        """Query returns empty list when nothing matches."""
        t = self._setup_tract_with_configs()
        results = t.query_by_config("model", "=", "nonexistent-model")
        assert len(results) == 0
        t.close()

    def test_invalid_operator(self):
        """Unsupported operator raises ValueError."""
        t = self._setup_tract_with_configs()
        with pytest.raises(ValueError, match="Unsupported operator"):
            t.query_by_config("model", "LIKE", "gpt%")
        t.close()

    def test_invalid_usage_raises_type_error(self):
        """Calling with wrong argument combination raises TypeError."""
        t = self._setup_tract_with_configs()
        with pytest.raises(TypeError, match="query_by_config requires"):
            t.query_by_config()
        t.close()
```

Also add tests for LLMConfig features that weren't tested in Plan 01's migration:

```python
class TestLLMConfigAdvanced:
    """Tests for LLMConfig from_dict/to_dict, round-trip, and edge cases."""

    def test_from_dict_round_trip(self):
        """from_dict(to_dict()) produces equal config."""
        config = LLMConfig(model="gpt-4o", temperature=0.7, top_p=0.9, seed=42)
        assert LLMConfig.from_dict(config.to_dict()) == config

    def test_from_dict_with_extra_keys(self):
        """Unknown keys go to extra field."""
        d = {"model": "gpt-4o", "custom_key": "custom_value", "another": 123}
        config = LLMConfig.from_dict(d)
        assert config.model == "gpt-4o"
        assert config.extra is not None
        assert config.extra["custom_key"] == "custom_value"
        assert config.extra["another"] == 123

    def test_round_trip_with_extra(self):
        """Extra keys survive round-trip."""
        d = {"model": "gpt-4o", "provider_specific": "abc"}
        config = LLMConfig.from_dict(d)
        result = config.to_dict()
        assert result == d

    def test_from_dict_none_returns_none(self):
        """from_dict(None) returns None."""
        assert LLMConfig.from_dict(None) is None

    def test_stop_sequences_as_tuple(self):
        """stop_sequences stored as tuple even when created with list."""
        config = LLMConfig(stop_sequences=["stop1", "stop2"])
        assert isinstance(config.stop_sequences, tuple)
        assert config.stop_sequences == ("stop1", "stop2")

    def test_stop_sequences_json_round_trip(self):
        """stop_sequences survives JSON round-trip (list -> tuple -> list -> tuple)."""
        config = LLMConfig(stop_sequences=("stop1", "stop2"))
        d = config.to_dict()
        assert isinstance(d["stop_sequences"], list)
        restored = LLMConfig.from_dict(d)
        assert restored.stop_sequences == ("stop1", "stop2")

    def test_extra_is_immutable(self):
        """extra field is MappingProxyType (immutable)."""
        import types
        config = LLMConfig(extra={"key": "value"})
        assert isinstance(config.extra, types.MappingProxyType)
        with pytest.raises(TypeError):
            config.extra["new_key"] = "new_value"

    def test_hashable(self):
        """LLMConfig can be used as dict key or set member."""
        c1 = LLMConfig(model="gpt-4o", temperature=0.7)
        c2 = LLMConfig(model="gpt-4o", temperature=0.7)
        assert hash(c1) == hash(c2)
        assert {c1, c2} == {c1}

    def test_non_none_fields(self):
        """non_none_fields returns only set fields."""
        config = LLMConfig(model="gpt-4o", temperature=0.7)
        assert config.non_none_fields() == {"model": "gpt-4o", "temperature": 0.7}

    def test_non_none_fields_empty(self):
        """non_none_fields on default config returns empty dict."""
        config = LLMConfig()
        assert config.non_none_fields() == {}

    def test_all_fields(self):
        """All 9 typed fields can be set and retrieved."""
        config = LLMConfig(
            model="gpt-4o",
            temperature=0.7,
            top_p=0.9,
            max_tokens=1000,
            stop_sequences=("stop",),
            frequency_penalty=0.5,
            presence_penalty=0.3,
            top_k=50,
            seed=42,
            extra={"custom": "val"},
        )
        assert config.model == "gpt-4o"
        assert config.temperature == 0.7
        assert config.top_p == 0.9
        assert config.max_tokens == 1000
        assert config.stop_sequences == ("stop",)
        assert config.frequency_penalty == 0.5
        assert config.presence_penalty == 0.3
        assert config.top_k == 50
        assert config.seed == 42
        assert config.extra["custom"] == "val"
```

**Step 5: Run full test suite to confirm everything passes.**
  </action>
  <verify>
Run `python -m pytest tests/ -x -q` -- all tests pass (should be ~1010+ tests with new ones).

Run `python -m pytest tests/test_operation_config.py -v -k "QueryByConfig or LLMConfigAdvanced"` -- all new query and config tests pass.

Verify cookbook syntax: `python -c "import ast; ast.parse(open('cookbook/01_foundations/first_conversation.py').read()); ast.parse(open('cookbook/01_foundations/atomic_batch.py').read()); print('Cookbook syntax OK')"` -- prints OK.

Grep for `.get('model')` in cookbooks -- zero matches: `grep -r "\.get(" cookbook/01_foundations/` should return no generation_config.get() calls.
  </verify>
  <done>
query_by_config supports all three calling patterns with comprehensive tests. IN operator works for set membership queries. Whole-config LLMConfig matching works. All 3 Tier 1 cookbook examples use typed LLMConfig attribute access. Full test suite passes.
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/ -x -q` -- all tests pass (original + new)
2. Verify query patterns:
   - Single-field: `query_by_config("model", "=", "gpt-4o")` returns correct results
   - Multi-field AND: `query_by_config(conditions=[("model", "=", "gpt-4o"), ("temperature", ">", 0.5)])` returns subset
   - IN operator: `query_by_config(conditions=[("model", "in", ["gpt-4o", "gpt-4o-mini"])])` returns union
   - Whole-config: `query_by_config(LLMConfig(model="gpt-4o"))` returns matching commits
3. Cookbook syntax valid and uses typed access (`.model` not `.get("model")`)
4. No `generation_config.get(` patterns remain in cookbook/01_foundations/
</verification>

<success_criteria>
- query_by_config supports three calling patterns: single-field, multi-field AND, whole-config
- IN operator works: query_by_config(conditions=[("model", "in", [...])])
- Whole-config match works: query_by_config(LLMConfig(model="x", temperature=0.7))
- Backward compatibility: existing query_by_config("field", "op", value) unchanged
- All 3 Tier 1 cookbooks use LLMConfig typed access
- All tests pass (original + ~20 new query/config tests)
</success_criteria>

<output>
After completion, create `.planning/phases/11-unified-llm-config-query/11-02-SUMMARY.md`
</output>
