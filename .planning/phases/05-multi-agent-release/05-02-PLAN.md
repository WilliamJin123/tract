---
phase: 05-multi-agent-release
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/tract/session.py
  - src/tract/operations/spawn.py
  - src/tract/operations/session_ops.py
  - src/tract/tract.py
  - src/tract/__init__.py
  - tests/test_session.py
  - tests/test_spawn.py
autonomous: true

must_haves:
  truths:
    - "Session.open() creates a shared-DB multi-agent entry point"
    - "Session.create_tract() creates a new tract with its own SQLAlchemy session sharing the engine"
    - "session.spawn() creates a child tract linked to parent via spawn pointer, with head_snapshot inheritance by default"
    - "session.collapse() compresses child tract history into a summary commit in the parent tract"
    - "session.collapse() supports manual (user text), collaborative (LLM draft + review), and autonomous (LLM auto-commit) modes"
    - "Tract.parent() returns the SpawnInfo of this tract's parent (or None for root tracts)"
    - "Tract.children() returns SpawnInfo list of child tracts spawned from this tract"
    - "session.timeline() returns all commits across all tracts ordered by created_at"
    - "session.search() finds commits matching a search term across all tracts using LIKE"
    - "session.compile_at() compiles any tract at a historical point-in-time"
    - "session.resume() finds the most recent active tract (no session_type='end' commit)"
    - "session.list_tracts() lists all tract IDs and their metadata in the shared DB"
    - "Crash recovery works: reopen Session.open() after simulated crash resumes from last committed state"
  artifacts:
    - path: "src/tract/session.py"
      provides: "Session class: multi-agent entry point"
      contains: "class Session"
    - path: "src/tract/operations/spawn.py"
      provides: "spawn, collapse, _head_snapshot, _full_clone operations"
      contains: "def spawn_tract"
    - path: "src/tract/operations/session_ops.py"
      provides: "timeline, search, compile_at, resume, list_tracts"
      contains: "def timeline"
    - path: "src/tract/tract.py"
      provides: "parent(), children() relationship helpers on Tract"
      contains: "def parent"
    - path: "tests/test_session.py"
      provides: "Session and cross-repo query tests"
      contains: "test_session_open"
    - path: "tests/test_spawn.py"
      provides: "Spawn, collapse, and inheritance tests"
      contains: "test_spawn_head_snapshot"
  key_links:
    - from: "src/tract/session.py"
      to: "src/tract/operations/spawn.py"
      via: "Session.spawn() delegates to spawn_tract() operation"
      pattern: "spawn_tract"
    - from: "src/tract/session.py"
      to: "src/tract/operations/session_ops.py"
      via: "Session.timeline/search/compile_at/resume delegates to session_ops"
      pattern: "timeline"
    - from: "src/tract/operations/spawn.py"
      to: "src/tract/storage/sqlite.py"
      via: "spawn_tract creates spawn pointer via SpawnPointerRepository"
      pattern: "spawn_repo.save"
    - from: "src/tract/operations/spawn.py"
      to: "src/tract/prompts/summarize.py"
      via: "collapse uses build_collapse_prompt for LLM summary"
      pattern: "build_collapse_prompt"
    - from: "src/tract/tract.py"
      to: "src/tract/storage/sqlite.py"
      via: "Tract.parent() and children() query SpawnPointerRepository"
      pattern: "spawn_repo"
---

<objective>
Build the Session class (multi-agent entry point), spawn/collapse operations, cross-repo queries, and Tract relationship helpers.

Purpose: This is the core multi-agent functionality -- spawning child tracts, collapsing results back, querying across tracts, and session lifecycle management. It builds on the storage foundation from 05-01 and delivers the MAGT-01 through MAGT-07 requirements.

Output: Session class, spawn/collapse operations (3 autonomy modes), 5 cross-repo query operations, Tract.parent()/children() helpers, crash recovery via resume(), and ~45 tests. All existing 586 tests continue to pass.
</objective>

<execution_context>
@C:\Users\jinwi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jinwi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-multi-agent-release/05-CONTEXT.md
@.planning/phases/05-multi-agent-release/05-RESEARCH.md
@.planning/phases/05-multi-agent-release/05-01-SUMMARY.md
@src/tract/tract.py
@src/tract/storage/engine.py
@src/tract/storage/sqlite.py
@src/tract/operations/compression.py
@src/tract/prompts/summarize.py
@src/tract/models/session.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Session class, spawn/collapse operations, and Tract helpers</name>
  <files>
    src/tract/session.py
    src/tract/operations/spawn.py
    src/tract/tract.py
  </files>
  <action>
    **session.py** -- Create new file with the `Session` class:

    ```python
    class Session:
        """Multi-agent entry point backed by a single shared SQLite DB.

        All tracts in a session share one SQLite file and engine.
        Each tract gets its own SQLAlchemy session for thread safety.
        """
    ```

    Construction:
    - `__init__(self, engine, session_factory, spawn_repo, db_path)`: Store engine, session_factory (sessionmaker), SqliteSpawnPointerRepository, db_path. Initialize `_tracts: dict[str, Tract]` cache.
    - `@classmethod open(cls, path: str, *, autonomy: str = "collaborative") -> Session`: Create engine via `create_trace_engine(path)`, call `init_db(engine)`, create `session_factory = create_session_factory(engine)`, create a session from the factory for the spawn repo, create `SqliteSpawnPointerRepository(session)`, return `cls(engine, session_factory, spawn_repo, path)`. Store `_autonomy` default.

    Tract management:
    - `create_tract(self, *, display_name: str | None = None, tract_id: str | None = None, config: TractConfig | None = None) -> Tract`: Create a fresh Tract using the shared engine. Create a new session from `self._session_factory()`. Build repositories and Tract instance similarly to `Tract.open()` but reusing the engine and passing a new session. Add the spawn_repo to the tract (see Tract modifications). Register tract in `self._tracts`.
    - `get_tract(self, tract_id: str) -> Tract`: Get a previously-created or -opened tract from the session. If not in cache, create Tract from existing DB data (look up refs for this tract_id). Raise SessionError if tract_id not found in DB.
    - `list_tracts(self) -> list[dict]`: Delegate to `session_ops.list_tracts()`.

    Spawn/collapse:
    - `spawn(self, parent: Tract, *, purpose: str, inheritance: str = "head_snapshot", display_name: str | None = None) -> Tract`: Delegate to `spawn_tract()` from operations/spawn.py. Returns the new child Tract.
    - `collapse(self, child: Tract, into: Tract, *, content: str | None = None, instructions: str | None = None, auto_commit: bool | None = None, target_tokens: int | None = None) -> CollapseResult`: Delegate to `collapse_tract()` from operations/spawn.py. `auto_commit` defaults to True if autonomy is "autonomous", None (review mode) if "collaborative", and must have `content` if "manual".

    Cross-repo queries:
    - `timeline(self, *, limit: int | None = None) -> list[CommitInfo]`: Delegate to `session_ops.timeline()`.
    - `search(self, term: str, *, tract_id: str | None = None) -> list[CommitInfo]`: Delegate to `session_ops.search()`.
    - `compile_at(self, tract_id: str, *, at_time: datetime | None = None, at_commit: str | None = None) -> CompiledContext`: Delegate to `session_ops.compile_at()`.
    - `resume(self) -> Tract | None`: Delegate to `session_ops.resume()`.

    Context manager:
    - `__enter__ / __exit__`: Manage engine lifecycle. On exit, close all tract sessions and dispose engine.
    - `close(self)`: Explicit close.

    **operations/spawn.py** -- Create new file with spawn and collapse operations:

    1. `spawn_tract(session_factory, engine, spawn_repo, parent_tract, *, purpose, inheritance, display_name) -> Tract`:
       - Validate cycle: `spawn_repo.has_ancestor(parent_tract.tract_id, new_child_id)` -- but since child is new, this is only relevant for re-spawning from an existing child. Skip for now (new tract IDs are always unique UUIDs).
       - Generate child tract_id via `uuid.uuid4().hex`
       - Create spawn pointer: `spawn_repo.save(parent_tract_id, parent_head_hash, child_tract_id, purpose, inheritance, display_name, now)`
       - Create spawn commit in parent: `parent_tract.commit(DialogueContent(role="system", text=f"Spawned subagent for: {purpose}"), message=f"spawn: {purpose}")`
       - Apply inheritance:
         - `"head_snapshot"`: Compile parent at HEAD, create initial APPEND commit in child with the compiled text (as InstructionContent with the full compiled context text)
         - `"full_clone"`: Call `_full_clone(parent_tract, child_session, child_repos, ...)` -- replay all parent commits via CommitEngine.create_commit() with new tract_id and timestamps
         - `"selective"`: Raise NotImplementedError for v1 (defer to future)
       - Build child Tract instance (similar to Session.create_tract flow)
       - Return child Tract

    2. `_head_snapshot(parent_tract, child_commit_engine) -> str`:
       - Compile parent's context: `parent_tract.compile()`
       - Format compiled messages into a single text blob
       - Commit as InstructionContent in child via commit_engine
       - Return child's HEAD hash

    3. `_full_clone(parent_tract, child_commit_engine, child_commit_repo, child_blob_repo, child_ref_repo, child_annotation_repo) -> str`:
       - Get all commits from parent in chronological order (oldest first)
       - For each commit: read blob content, create_commit() in child with same content/operation/message but new tract_id
       - Copy annotations for each commit
       - Return child's HEAD hash
       - NOTE: commit_hashes will differ (new timestamps), which is correct behavior

    4. `collapse_tract(parent_tract, child_tract, spawn_repo, *, content, instructions, auto_commit, target_tokens, llm_client) -> CollapseResult`:
       - Get spawn pointer via `spawn_repo.get_by_child(child_tract.tract_id)`
       - Raise SpawnError if no spawn pointer found
       - Compile child's full context
       - If `content` is provided (manual mode): use it directly as summary text
       - If `content` is None (collaborative/autonomous): use LLM via child's configured client
         - Build prompt with `build_collapse_prompt(messages_text, purpose, target_tokens=..., instructions=...)`
         - System prompt = DEFAULT_COLLAPSE_SYSTEM
         - Call LLM (from parent_tract's llm_client if configured, or raise SpawnError if no client and no manual content)
       - If `auto_commit` is True: commit summary to parent as DialogueContent(role="assistant", text=summary), with metadata `{"collapse_source_tract_id": child_id, "collapse_source_head": child_head}`
       - If `auto_commit` is False or None: return CollapseResult without committing (caller reviews and commits)
       - Return CollapseResult(parent_commit_hash, child_tract_id, summary_tokens, source_tokens, purpose)

    **tract.py** -- Add spawn-related helpers and spawn_repo support:

    1. Add `spawn_repo: SqliteSpawnPointerRepository | None = None` parameter to `__init__()`. Store as `self._spawn_repo`.
    2. Add to `Tract.open()`: create `SqliteSpawnPointerRepository(session)` and pass to constructor.
    3. Add `parent(self) -> SpawnInfo | None`: If `self._spawn_repo` is None, return None. Query `spawn_repo.get_by_child(self._tract_id)`. Convert SpawnPointerRow to SpawnInfo dataclass and return (or None).
    4. Add `children(self) -> list[SpawnInfo]`: If `self._spawn_repo` is None, return []. Query `spawn_repo.get_children(self._tract_id)`. Convert each to SpawnInfo and return.
    5. Add `@property spawn_repo(self)`: Expose `self._spawn_repo` for internal use by Session.

    Import SpawnInfo from `tract.models.session`. Import SqliteSpawnPointerRepository from storage.
  </action>
  <verify>
    Run `python -c "from tract.session import Session; print('OK')"` -- Session importable.
    Run `python -c "from tract.operations.spawn import spawn_tract, collapse_tract; print('OK')"` -- operations importable.
    Run `python -c "from tract import Tract; t = Tract.open(); assert t.parent() is None; print('OK')"` -- Tract.parent() works for root tract.
  </verify>
  <done>
    Session class with open/create_tract/spawn/collapse/timeline/search/compile_at/resume/list_tracts. spawn_tract() and collapse_tract() operations with head_snapshot and full_clone inheritance. Tract.parent() and Tract.children() helpers. All existing tests still pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Cross-repo query operations, exports, and comprehensive tests</name>
  <files>
    src/tract/operations/session_ops.py
    src/tract/__init__.py
    tests/test_session.py
    tests/test_spawn.py
  </files>
  <action>
    **operations/session_ops.py** -- Create new file with cross-repo query functions:

    1. `list_tracts(session, spawn_repo) -> list[dict]`:
       - Query distinct tract_ids from CommitRow
       - For each tract_id: get latest commit timestamp, commit count, check if it has a session_type="end" commit, check spawn_repo for parent/children info
       - Return list of dicts: `{"tract_id": str, "display_name": str|None, "commit_count": int, "latest_commit_at": datetime, "is_active": bool, "parent_tract_id": str|None}`

    2. `timeline(session, *, limit: int | None = None) -> list[CommitInfo]`:
       - Query all CommitRows across all tract_ids, ordered by created_at ASC
       - Apply limit if provided
       - Convert each CommitRow to CommitInfo (load blob content for each)
       - Return list of CommitInfo

    3. `search(session, blob_repo, term: str, *, tract_id: str | None = None) -> list[CommitInfo]`:
       - Query BlobRow where payload_json LIKE '%{term}%'
       - Join with CommitRow to get commit info
       - Filter by tract_id if provided
       - Convert to CommitInfo and return
       - Use `BlobRow.payload_json.like(f"%{term}%")` for the LIKE query

    4. `compile_at(session_factory, engine, tract_id: str, *, at_time: datetime | None = None, at_commit: str | None = None) -> CompiledContext`:
       - Create a temporary Tract for the target tract_id (using session_factory)
       - Call `tract.compile(at_time=at_time, at_commit=at_commit)`
       - Return the CompiledContext

    5. `resume(session, spawn_repo) -> dict | None`:
       - List all active tracts (no session_type="end" commit)
       - Among those, prefer root tracts (no parent in spawn_pointers) with the latest commit
       - Return dict with tract_id and metadata, or None if no active tracts
       - The Session class uses this to open/return the appropriate Tract

    All functions accept a SQLAlchemy session and necessary repos as parameters (pure functions, no class state). Use CommitInfo from tract.models.commit. Use _row_to_commit_info helper for conversion (same pattern as existing operations).

    **__init__.py** -- Update exports:
    - Add imports for: `Session` from `tract.session`, `SessionContent` from `tract.models.session`, `SpawnInfo` from `tract.models.session`, `CollapseResult` from `tract.models.session`, `SpawnError` from `tract.exceptions`, `SessionError` from `tract.exceptions`
    - Add all to `__all__` list

    **tests/test_spawn.py** -- Create test file (~25 tests) covering spawn and collapse:

    1. Spawn tests (~10 tests):
       - `test_spawn_head_snapshot`: spawn with head_snapshot inheritance, child gets compiled parent context
       - `test_spawn_creates_parent_commit`: spawning creates a commit in the parent documenting the spawn
       - `test_spawn_creates_pointer`: spawn pointer exists in DB with correct fields
       - `test_spawn_full_clone`: spawn with full_clone, child gets all parent commits (different hashes)
       - `test_spawn_full_clone_preserves_content`: cloned commits have same content as originals
       - `test_spawn_selective_not_implemented`: spawn with selective raises NotImplementedError
       - `test_spawn_purpose_required`: spawn without purpose raises TypeError
       - `test_spawn_display_name_optional`: display_name stored when provided, None when not
       - `test_spawn_recursive`: tract A spawns B, B spawns C -- all pointers correct
       - `test_tract_parent_and_children`: Tract.parent() and Tract.children() return correct SpawnInfo

    2. Collapse tests (~8 tests):
       - `test_collapse_manual`: collapse with user-provided content, summary commit in parent
       - `test_collapse_creates_commit_in_parent`: summary commit exists in parent with metadata
       - `test_collapse_metadata`: collapse commit has collapse_source_tract_id and collapse_source_head metadata
       - `test_collapse_without_llm_and_no_content_raises`: collaborative mode without LLM client raises SpawnError
       - `test_collapse_auto_commit_false`: collapse with auto_commit=False returns result without committing
       - `test_collapse_multiple_times`: subagent can be collapsed multiple times (interim progress)
       - `test_collapse_result_fields`: CollapseResult has correct parent_commit_hash, tokens, purpose
       - `test_collapse_preserves_child_tract`: after collapse, child tract and its commits still exist

    3. Inheritance detail tests (~3 tests):
       - `test_head_snapshot_single_commit`: child gets one commit with compiled context
       - `test_full_clone_annotation_copy`: annotations are copied during full clone
       - `test_head_snapshot_empty_parent`: spawning from empty parent creates child with no commits

    For tests needing LLM: mock the LLM client to return a fixed summary string. Use `unittest.mock.patch` or `unittest.mock.MagicMock`.

    **tests/test_session.py** -- Create test file (~20 tests) covering Session and cross-repo queries:

    1. Session lifecycle tests (~6 tests):
       - `test_session_open`: Session.open() creates engine and returns Session
       - `test_session_create_tract`: create_tract() returns a Tract that can commit
       - `test_session_get_tract`: get_tract() retrieves a previously created tract
       - `test_session_get_tract_not_found`: get_tract() raises SessionError for unknown tract_id
       - `test_session_list_tracts`: list_tracts() returns all tracts with metadata
       - `test_session_context_manager`: Session works as context manager

    2. Cross-repo query tests (~8 tests):
       - `test_timeline_chronological`: timeline() returns commits from all tracts in time order
       - `test_timeline_with_limit`: timeline(limit=5) returns at most 5 commits
       - `test_search_finds_matching`: search("keyword") finds commits containing the keyword
       - `test_search_scoped_to_tract`: search("keyword", tract_id=X) only returns commits from tract X
       - `test_search_no_results`: search("nonexistent") returns empty list
       - `test_compile_at_time`: compile_at(tract_id, at_time=T) compiles tract as of time T
       - `test_compile_at_commit`: compile_at(tract_id, at_commit=H) compiles tract up to commit H
       - `test_session_content_queryable`: SessionContent commits are queryable by content_type "session"

    3. Resume / crash recovery tests (~6 tests):
       - `test_resume_finds_latest_active`: resume() returns most recent active tract
       - `test_resume_skips_ended_tracts`: tract with session_type="end" commit is not returned
       - `test_resume_prefers_root_tracts`: root tract preferred over child tracts
       - `test_resume_empty_db`: resume() returns None for empty session
       - `test_crash_recovery`: create tracts, "crash" (close session), reopen, verify all commits intact
       - `test_resume_after_crash`: create tract, commit, close, reopen, resume() finds the tract

    All tests use temporary file-based databases (not :memory:) since Session manages its own engine. Use `tmp_path` fixture from pytest for temp directories.
  </action>
  <verify>
    Run `python -m pytest tests/test_spawn.py -v` -- all ~25 spawn/collapse tests pass.
    Run `python -m pytest tests/test_session.py -v` -- all ~20 session/query tests pass.
    Run `python -m pytest tests/ -x -q` -- all tests pass (586 existing + ~45 new = ~631 total).
    Run `python -c "from tract import Session, SessionContent, SpawnInfo, CollapseResult, SpawnError, SessionError; print('OK')"` -- all exports work.
  </verify>
  <done>
    session_ops.py with 5 cross-repo query functions. Session class fully functional with spawn/collapse/timeline/search/compile_at/resume/list_tracts. Tract.parent() and children() helpers wired. All new models exported from tract.__init__. ~45 new tests covering spawn, collapse, session lifecycle, cross-repo queries, and crash recovery. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/ -x -q` -- all tests pass (586 existing + ~45 new)
2. `python -c "from tract import Session; s = Session.open(':memory:'); print('OK')"` -- Session creates
3. Multi-agent workflow test: create session, create parent tract, spawn child, commit in child, collapse back, verify summary in parent
4. Cross-repo query test: timeline() returns commits from multiple tracts
5. Crash recovery test: close and reopen session, resume() finds the right tract
6. `python -c "from tract import Session, SessionContent, SpawnInfo, CollapseResult, SpawnError, SessionError"` -- all exports work
</verification>

<success_criteria>
1. Session.open() is the multi-agent entry point; Tract.open() remains for single-agent backward compatibility
2. session.spawn() creates child tracts with head_snapshot (default) or full_clone inheritance
3. session.collapse() compresses child trace into parent summary commit (3 autonomy modes)
4. Tract.parent() and Tract.children() expose spawn graph relationships
5. session.timeline(), search(), compile_at() provide cross-repo queries
6. session.resume() finds the most recent active tract for crash recovery
7. All new types exported from tract.__init__
8. ~45 new tests pass; ~586 existing tests have zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/05-multi-agent-release/05-02-SUMMARY.md`
</output>
