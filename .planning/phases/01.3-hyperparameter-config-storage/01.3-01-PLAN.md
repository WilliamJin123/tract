---
phase: 01.3-hyperparameter-config-storage
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/tract/models/commit.py
  - src/tract/storage/schema.py
  - src/tract/storage/repositories.py
  - src/tract/storage/sqlite.py
  - src/tract/engine/commit.py
  - src/tract/engine/compiler.py
  - src/tract/protocols.py
  - src/tract/tract.py
  - tests/test_tract.py
autonomous: true

must_haves:
  truths:
    - "User can attach a generation config dict to any commit via tract.commit(..., generation_config={...}) and retrieve it from CommitInfo.generation_config"
    - "generation_config is stored as a nullable JSON blob in SQLite, accepting any provider's parameters without migration"
    - "CompiledContext.generation_configs is a list of dicts parallel to effective commits (pre-aggregation), preserving the 1:1 commit-to-config mapping through compilation"
    - "record_usage() accepts an optional generation_config kwarg that updates/sets the HEAD commit's generation_config"
    - "User can query commits by config values via tract.query_by_config(field, operator, value) using SQL-side json_extract()"
    - "Incremental compile cache (CompileSnapshot) carries generation_configs through snapshot-to-compiled conversion"
    - "generation_config is NOT included in commit hash computation (same content + different config = same hash)"
  artifacts:
    - path: "src/tract/models/commit.py"
      provides: "generation_config field on CommitInfo"
      contains: "generation_config"
    - path: "src/tract/storage/schema.py"
      provides: "generation_config_json column on CommitRow"
      contains: "generation_config_json"
    - path: "src/tract/storage/repositories.py"
      provides: "get_by_config abstract method on CommitRepository"
      contains: "get_by_config"
    - path: "src/tract/storage/sqlite.py"
      provides: "get_by_config implementation using func.json_extract"
      contains: "json_extract"
    - path: "src/tract/engine/commit.py"
      provides: "generation_config param threaded through create_commit and _row_to_info"
      contains: "generation_config"
    - path: "src/tract/protocols.py"
      provides: "generation_configs field on CompiledContext and CompileSnapshot"
      contains: "generation_configs"
    - path: "src/tract/tract.py"
      provides: "generation_config param on commit(), record_usage(), query_by_config() method"
      contains: "query_by_config"
    - path: "tests/test_tract.py"
      provides: "Tests covering all 5 success criteria for generation config"
      contains: "generation_config"
  key_links:
    - from: "src/tract/tract.py"
      to: "src/tract/engine/commit.py"
      via: "generation_config param passed through commit()"
      pattern: "generation_config"
    - from: "src/tract/engine/commit.py"
      to: "src/tract/storage/schema.py"
      via: "generation_config_json stored on CommitRow"
      pattern: "generation_config_json"
    - from: "src/tract/tract.py"
      to: "src/tract/protocols.py"
      via: "CompileSnapshot.generation_configs carried through compile cache"
      pattern: "generation_configs"
    - from: "src/tract/tract.py"
      to: "src/tract/storage/sqlite.py"
      via: "query_by_config delegates to SqliteCommitRepository.get_by_config"
      pattern: "get_by_config"
---

<objective>
Add generation config (LLM hyperparameter) storage to the commit model, threading it through the full commit/compile/record_usage/query pipeline.

Purpose: Every commit can now store the exact LLM generation config (temperature, top_p, model, etc.) used at call time, giving full provenance for how each piece of context was generated. This enables downstream patterns like exploration/exploitation branching where hyperparams are tuned per-branch and results compared.

Output: A `generation_config: Optional[dict]` field on CommitInfo, `generation_config_json` column on CommitRow, generation_configs list on CompiledContext/CompileSnapshot, `query_by_config()` on Tract, and comprehensive tests for all 5 success criteria.
</objective>

<execution_context>
@C:\Users\jinwi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jinwi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01.3-hyperparameter-config-storage/01.3-RESEARCH.md
@src/tract/models/commit.py
@src/tract/storage/schema.py
@src/tract/storage/repositories.py
@src/tract/storage/sqlite.py
@src/tract/engine/commit.py
@src/tract/engine/compiler.py
@src/tract/protocols.py
@src/tract/tract.py
@src/tract/__init__.py
@tests/test_tract.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add generation_config field to data model, storage schema, engine, and compiler</name>
  <files>
    src/tract/models/commit.py
    src/tract/storage/schema.py
    src/tract/storage/repositories.py
    src/tract/storage/sqlite.py
    src/tract/engine/commit.py
    src/tract/engine/compiler.py
    src/tract/protocols.py
  </files>
  <action>
    **1a. Add generation_config to CommitInfo (models/commit.py):**

    Add a new optional field after `metadata`:

    ```python
    generation_config: Optional[dict] = None
    ```

    This field holds the LLM generation configuration (temperature, top_p, model, etc.) as a flexible dict.

    **1b. Add generation_config_json column to CommitRow (storage/schema.py):**

    Add a new nullable JSON column after `metadata_json`:

    ```python
    generation_config_json: Mapped[Optional[dict]] = mapped_column(JSON, nullable=True)
    ```

    This follows the exact same pattern as `metadata_json`.

    **1c. Add get_by_config abstract method to CommitRepository (storage/repositories.py):**

    Add a new abstract method to the `CommitRepository` ABC:

    ```python
    @abstractmethod
    def get_by_config(
        self, tract_id: str, json_path: str, operator: str, value: object
    ) -> Sequence[CommitRow]:
        """Get commits where generation_config matches the given condition.

        Args:
            tract_id: Tract identifier to scope the query.
            json_path: JSON field name (e.g., "temperature", "model").
            operator: Comparison operator ("=", "!=", ">", "<", ">=", "<=").
            value: Value to compare against.

        Returns:
            Matching commits ordered by created_at ascending.
        """
        ...
    ```

    **1d. Implement get_by_config in SqliteCommitRepository (storage/sqlite.py):**

    Add the concrete implementation using `func.json_extract()`:

    ```python
    def get_by_config(
        self, tract_id: str, json_path: str, operator: str, value: object
    ) -> Sequence[CommitRow]:
        extracted = func.json_extract(
            CommitRow.generation_config_json, f'$.{json_path}'
        )
        ops = {
            "=": lambda e, v: e == v,
            "!=": lambda e, v: e != v,
            ">": lambda e, v: e > v,
            "<": lambda e, v: e < v,
            ">=": lambda e, v: e >= v,
            "<=": lambda e, v: e <= v,
        }
        if operator not in ops:
            raise ValueError(f"Unsupported operator: {operator}. Use one of: {list(ops.keys())}")
        condition = ops[operator](extracted, value)
        stmt = (
            select(CommitRow)
            .where(CommitRow.tract_id == tract_id, condition)
            .order_by(CommitRow.created_at)
        )
        return list(self._session.execute(stmt).scalars().all())
    ```

    **1e. Thread generation_config through CommitEngine (engine/commit.py):**

    - Add `generation_config: dict | None = None` parameter to `create_commit()` method signature (after `metadata`).
    - Pass it to the CommitRow constructor as `generation_config_json=generation_config`.
    - Include it in the returned CommitInfo: `generation_config=generation_config`.
    - Update `_row_to_info()` to map `row.generation_config_json` to `generation_config`.
    - Do NOT include generation_config in the commit hash computation (it is NOT part of the hash, same decision as metadata).

    The updated `create_commit()` signature:
    ```python
    def create_commit(
        self,
        content: BaseModel,
        operation: CommitOperation = CommitOperation.APPEND,
        message: str | None = None,
        response_to: str | None = None,
        metadata: dict | None = None,
        generation_config: dict | None = None,
    ) -> CommitInfo:
    ```

    In the CommitRow construction (step 10), add:
    ```python
    generation_config_json=generation_config,
    ```

    In the returned CommitInfo (step 13), add:
    ```python
    generation_config=generation_config,
    ```

    In `_row_to_info()`, add:
    ```python
    generation_config=row.generation_config_json,
    ```

    **1f. Add generation_configs to CompiledContext and CompileSnapshot (protocols.py):**

    Add a new field to `CompiledContext`:
    ```python
    generation_configs: list[dict] = field(default_factory=list)
    ```

    This is a list parallel to the effective commits (pre-aggregation). Each entry is the generation_config dict for the corresponding effective commit, or an empty dict `{}` if none was set.

    Add a new field to `CompileSnapshot`:
    ```python
    generation_configs: tuple[dict, ...] = ()
    ```

    This stores generation_configs as an immutable tuple for the snapshot cache.

    **1g. Collect generation_configs during compilation (engine/compiler.py):**

    In `DefaultContextCompiler.compile()`, after building the effective commit list (Step 4), collect generation configs from the effective commits. Between Step 4 and Step 5 in the `compile()` method:

    ```python
    # Step 4b: Collect generation configs for effective commits
    generation_configs: list[dict] = []
    for c in effective_commits:
        source_commit = edit_map.get(c.commit_hash, c)
        config = getattr(source_commit, 'generation_config_json', None) or {}
        generation_configs.append(config)
    ```

    Pass `generation_configs` into the returned CompiledContext:
    ```python
    return CompiledContext(
        messages=messages,
        token_count=token_count,
        commit_count=len(effective_commits),
        token_source=token_source,
        generation_configs=generation_configs,
    )
    ```
  </action>
  <verify>
    Run: `python -m pytest tests/ -v --tb=short`
    All existing 220 tests should pass (no behavioral change for existing code paths where generation_config is None).
    Verify the new column is created: `python -c "from tract.storage.schema import CommitRow; print(CommitRow.__table__.columns.keys())"` -- should include `generation_config_json`.
  </verify>
  <done>
    CommitInfo has generation_config field. CommitRow has generation_config_json column. CommitEngine threads the param through create_commit and _row_to_info. CommitRepository has get_by_config ABC and SQLite implementation. CompiledContext and CompileSnapshot have generation_configs field. DefaultContextCompiler collects configs during compile. All 220 existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire generation_config through Tract facade and add integration tests</name>
  <files>
    src/tract/tract.py
    tests/test_tract.py
  </files>
  <action>
    **2a. Add generation_config to Tract.commit():**

    Add `generation_config: dict | None = None` kwarg to the `commit()` method signature:

    ```python
    def commit(
        self,
        content: BaseModel | dict,
        *,
        operation: CommitOperation = CommitOperation.APPEND,
        message: str | None = None,
        response_to: str | None = None,
        metadata: dict | None = None,
        generation_config: dict | None = None,
    ) -> CommitInfo:
    ```

    Pass it through to `self._commit_engine.create_commit(... generation_config=generation_config)`.

    **2b. Update _extend_snapshot_for_append to carry generation_configs:**

    In `_extend_snapshot_for_append()`, after getting the commit_row, get its generation_config:

    ```python
    new_config = commit_row.generation_config_json or {}
    ```

    When constructing the new CompileSnapshot, extend generation_configs:
    ```python
    self._compile_snapshot = CompileSnapshot(
        head_hash=commit_info.commit_hash,
        raw_messages=new_raw,
        aggregated_messages=new_aggregated,
        effective_hashes=snapshot.effective_hashes | {commit_info.commit_hash},
        commit_count=snapshot.commit_count + 1,
        token_count=new_token_count,
        token_source=self._tiktoken_source(),
        generation_configs=snapshot.generation_configs + (new_config,),
    )
    ```

    **2c. Update _snapshot_to_compiled to pass generation_configs:**

    ```python
    def _snapshot_to_compiled(self, snapshot: CompileSnapshot) -> CompiledContext:
        return CompiledContext(
            messages=list(snapshot.aggregated_messages),
            token_count=snapshot.token_count,
            commit_count=snapshot.commit_count,
            token_source=snapshot.token_source,
            generation_configs=list(snapshot.generation_configs),
        )
    ```

    **2d. Update _build_snapshot_from_compiled to capture generation_configs:**

    ```python
    def _build_snapshot_from_compiled(
        self, head_hash: str, result: CompiledContext
    ) -> CompileSnapshot | None:
        if not isinstance(self._compiler, DefaultContextCompiler):
            return None
        return CompileSnapshot(
            head_hash=head_hash,
            raw_messages=tuple(result.messages),
            aggregated_messages=tuple(result.messages),
            effective_hashes=frozenset(),
            commit_count=result.commit_count,
            token_count=result.token_count,
            token_source=result.token_source,
            generation_configs=tuple(result.generation_configs),
        )
    ```

    **2e. Update record_usage() to accept optional generation_config:**

    Add `generation_config: dict | None = None` kwarg to `record_usage()`:

    ```python
    def record_usage(
        self,
        usage: TokenUsage | dict,
        *,
        head_hash: str | None = None,
        generation_config: dict | None = None,
    ) -> CompiledContext:
    ```

    After the head_hash validation, if `generation_config is not None`, update the HEAD commit's generation_config in the database:

    ```python
    # Update generation_config on HEAD commit if provided
    if generation_config is not None:
        commit_row = self._commit_repo.get(target_hash)
        if commit_row is not None:
            commit_row.generation_config_json = generation_config
            self._session.flush()
            self._session.commit()
    ```

    Also update record_usage's snapshot reconstruction to carry generation_configs through. When constructing the updated CompileSnapshot inside record_usage, preserve the existing generation_configs:

    ```python
    self._compile_snapshot = CompileSnapshot(
        head_hash=self._compile_snapshot.head_hash,
        raw_messages=self._compile_snapshot.raw_messages,
        aggregated_messages=self._compile_snapshot.aggregated_messages,
        effective_hashes=self._compile_snapshot.effective_hashes,
        commit_count=self._compile_snapshot.commit_count,
        token_count=usage.prompt_tokens,
        token_source=token_source,
        generation_configs=self._compile_snapshot.generation_configs,
    )
    ```

    **2f. Add query_by_config() method to Tract:**

    Add a new public method:

    ```python
    def query_by_config(
        self,
        field: str,
        operator: str,
        value: object,
    ) -> list[CommitInfo]:
        """Query commits by generation config values.

        Uses SQL-side json_extract() for efficient filtering.

        Args:
            field: JSON field name in the generation config (e.g., "temperature", "model").
            operator: Comparison operator ("=", "!=", ">", "<", ">=", "<=").
            value: Value to compare against.

        Returns:
            List of :class:`CommitInfo` matching the condition, ordered by created_at.
        """
        rows = self._commit_repo.get_by_config(
            self._tract_id, field, operator, value
        )
        return [self._commit_engine._row_to_info(row) for row in rows]
    ```

    **2g. Write integration tests in tests/test_tract.py:**

    Add a new test class `TestGenerationConfig` at the end of the test file:

    ```python
    class TestGenerationConfig:
        """Phase 1.3: Hyperparameter config storage tests."""

        # SC1: Attach and retrieve generation_config
        def test_commit_with_generation_config(self, tract: Tract):
            config = {"model": "gpt-4o", "temperature": 0.7, "top_p": 0.95}
            info = tract.commit(
                DialogueContent(role="user", text="Hello"),
                generation_config=config,
            )
            assert info.generation_config == config
            # Retrieve via get_commit
            fetched = tract.get_commit(info.commit_hash)
            assert fetched is not None
            assert fetched.generation_config == config

        def test_commit_without_generation_config(self, tract: Tract):
            info = tract.commit(DialogueContent(role="user", text="Hi"))
            assert info.generation_config is None
            fetched = tract.get_commit(info.commit_hash)
            assert fetched is not None
            assert fetched.generation_config is None

        def test_generation_config_in_log(self, tract: Tract):
            config = {"temperature": 0.9}
            tract.commit(
                DialogueContent(role="user", text="Hello"),
                generation_config=config,
            )
            entries = tract.log(limit=1)
            assert entries[0].generation_config == config

        # SC2: Flexible schema -- any provider params work
        def test_generation_config_arbitrary_provider_params(self, tract: Tract):
            openai_config = {"model": "gpt-4o", "temperature": 0.7, "frequency_penalty": 0.5}
            anthropic_config = {"model": "claude-3-opus", "top_k": 40, "temperature": 0.3}
            meta_config = {"model": "llama-3", "repetition_penalty": 1.2, "min_p": 0.05}

            c1 = tract.commit(DialogueContent(role="user", text="a"), generation_config=openai_config)
            c2 = tract.commit(DialogueContent(role="user", text="b"), generation_config=anthropic_config)
            c3 = tract.commit(DialogueContent(role="user", text="c"), generation_config=meta_config)

            assert c1.generation_config == openai_config
            assert c2.generation_config == anthropic_config
            assert c3.generation_config == meta_config

        # SC3: generation_configs preserved through compile
        def test_compile_exposes_generation_configs(self, tract: Tract):
            config1 = {"temperature": 0.5}
            config2 = {"temperature": 0.9}
            tract.commit(InstructionContent(text="System"), generation_config=config1)
            tract.commit(DialogueContent(role="user", text="Hi"), generation_config=config2)
            result = tract.compile()
            assert len(result.generation_configs) == 2
            assert result.generation_configs[0] == config1
            assert result.generation_configs[1] == config2

        def test_compile_empty_config_for_commits_without_config(self, tract: Tract):
            tract.commit(InstructionContent(text="System"))
            tract.commit(DialogueContent(role="user", text="Hi"), generation_config={"temperature": 0.7})
            result = tract.compile()
            assert result.generation_configs[0] == {}
            assert result.generation_configs[1] == {"temperature": 0.7}

        def test_compile_incremental_carries_generation_configs(self, tract: Tract):
            config1 = {"temperature": 0.3}
            config2 = {"temperature": 0.7}
            tract.commit(InstructionContent(text="System"), generation_config=config1)
            result1 = tract.compile()
            assert result1.generation_configs == [config1]

            tract.commit(DialogueContent(role="user", text="Hi"), generation_config=config2)
            result2 = tract.compile()
            assert result2.generation_configs == [config1, config2]

        def test_compile_edit_preserves_generation_config_of_replacement(self, tract: Tract):
            config_orig = {"temperature": 0.5}
            config_edit = {"temperature": 0.9}
            c1 = tract.commit(
                DialogueContent(role="user", text="original"),
                generation_config=config_orig,
            )
            tract.commit(
                DialogueContent(role="user", text="edited"),
                operation=CommitOperation.EDIT,
                response_to=c1.commit_hash,
                generation_config=config_edit,
            )
            result = tract.compile()
            # The effective commit's config comes from the edit replacement
            assert result.generation_configs[0] == config_edit

        # SC4: record_usage() with generation_config
        def test_record_usage_with_generation_config(self, tract: Tract):
            tract.commit(DialogueContent(role="user", text="Hello"))
            config = {"model": "gpt-4o", "temperature": 0.7}
            tract.record_usage(
                {"prompt_tokens": 100, "completion_tokens": 50, "total_tokens": 150},
                generation_config=config,
            )
            # Verify the HEAD commit now has the generation_config
            fetched = tract.get_commit(tract.head)
            assert fetched is not None
            assert fetched.generation_config == config

        def test_record_usage_overwrites_existing_generation_config(self, tract: Tract):
            old_config = {"temperature": 0.5}
            tract.commit(
                DialogueContent(role="user", text="Hello"),
                generation_config=old_config,
            )
            new_config = {"temperature": 0.8, "model": "gpt-4o"}
            tract.record_usage(
                {"prompt_tokens": 100, "completion_tokens": 50, "total_tokens": 150},
                generation_config=new_config,
            )
            fetched = tract.get_commit(tract.head)
            assert fetched is not None
            assert fetched.generation_config == new_config

        def test_record_usage_without_generation_config(self, tract: Tract):
            config = {"temperature": 0.5}
            tract.commit(
                DialogueContent(role="user", text="Hello"),
                generation_config=config,
            )
            tract.record_usage(
                {"prompt_tokens": 100, "completion_tokens": 50, "total_tokens": 150},
            )
            # Original config should be unchanged
            fetched = tract.get_commit(tract.head)
            assert fetched is not None
            assert fetched.generation_config == config

        # SC5: Query by config values
        def test_query_by_config_equality(self, tract: Tract):
            tract.commit(
                DialogueContent(role="user", text="a"),
                generation_config={"model": "gpt-4o", "temperature": 0.5},
            )
            tract.commit(
                DialogueContent(role="user", text="b"),
                generation_config={"model": "claude-3", "temperature": 0.9},
            )
            tract.commit(
                DialogueContent(role="user", text="c"),
                generation_config={"model": "gpt-4o", "temperature": 0.7},
            )
            results = tract.query_by_config("model", "=", "gpt-4o")
            assert len(results) == 2
            assert all(r.generation_config["model"] == "gpt-4o" for r in results)

        def test_query_by_config_greater_than(self, tract: Tract):
            tract.commit(
                DialogueContent(role="user", text="a"),
                generation_config={"temperature": 0.3},
            )
            tract.commit(
                DialogueContent(role="user", text="b"),
                generation_config={"temperature": 0.8},
            )
            tract.commit(
                DialogueContent(role="user", text="c"),
                generation_config={"temperature": 1.0},
            )
            results = tract.query_by_config("temperature", ">", 0.5)
            assert len(results) == 2
            assert all(r.generation_config["temperature"] > 0.5 for r in results)

        def test_query_by_config_no_matches(self, tract: Tract):
            tract.commit(
                DialogueContent(role="user", text="a"),
                generation_config={"temperature": 0.3},
            )
            results = tract.query_by_config("temperature", ">", 0.9)
            assert len(results) == 0

        def test_query_by_config_invalid_operator(self, tract: Tract):
            with pytest.raises(ValueError, match="Unsupported operator"):
                tract.query_by_config("temperature", "LIKE", 0.5)

        def test_query_by_config_commits_without_config_excluded(self, tract: Tract):
            tract.commit(DialogueContent(role="user", text="no config"))
            tract.commit(
                DialogueContent(role="user", text="with config"),
                generation_config={"temperature": 0.7},
            )
            results = tract.query_by_config("temperature", "=", 0.7)
            assert len(results) == 1

        # generation_config is NOT in commit hash
        def test_generation_config_not_in_hash(self, tract: Tract):
            """Same content with different generation_configs should produce different
            commit hashes ONLY because of timestamp differences, not config differences.
            Verify by checking that generation_config doesn't affect content_hash."""
            c1 = tract.commit(
                DialogueContent(role="user", text="identical"),
                generation_config={"temperature": 0.1},
            )
            c2 = tract.commit(
                DialogueContent(role="user", text="identical"),
                generation_config={"temperature": 0.9},
            )
            # content_hash should be the same (same content)
            assert c1.content_hash == c2.content_hash
            # commit_hash differs because of parent_hash and timestamp, not config
            assert c1.commit_hash != c2.commit_hash
    ```
  </action>
  <verify>
    Run: `python -m pytest tests/test_tract.py::TestGenerationConfig -v`
    All new generation config tests pass.

    Run: `python -m pytest tests/ -v`
    All 220 existing tests pass + new tests pass (no regressions).
  </verify>
  <done>
    Tract.commit() accepts generation_config kwarg and passes it through to storage. Tract.compile() returns generation_configs in CompiledContext. Tract.record_usage() accepts optional generation_config to update HEAD commit's config. Tract.query_by_config() provides SQL-side JSON querying. Incremental compile cache carries generation_configs. All 5 success criteria have passing tests. All existing 220 tests still pass.
  </done>
</task>

</tasks>

<verification>
Run the full test suite to ensure no regressions:

```bash
python -m pytest tests/ -v
```

Expected: All existing 220 tests pass + ~18 new generation config tests pass.

Verify all 5 success criteria:

1. **SC1** (attach and retrieve): `test_commit_with_generation_config`, `test_commit_without_generation_config`, `test_generation_config_in_log`
2. **SC2** (flexible schema): `test_generation_config_arbitrary_provider_params`
3. **SC3** (preserved through compile): `test_compile_exposes_generation_configs`, `test_compile_empty_config_for_commits_without_config`, `test_compile_incremental_carries_generation_configs`, `test_compile_edit_preserves_generation_config_of_replacement`
4. **SC4** (record_usage with config): `test_record_usage_with_generation_config`, `test_record_usage_overwrites_existing_generation_config`, `test_record_usage_without_generation_config`
5. **SC5** (queryable): `test_query_by_config_equality`, `test_query_by_config_greater_than`, `test_query_by_config_no_matches`, `test_query_by_config_invalid_operator`, `test_query_by_config_commits_without_config_excluded`
6. **Hash safety**: `test_generation_config_not_in_hash`
</verification>

<success_criteria>
1. `generation_config: Optional[dict]` field on CommitInfo, populated from `generation_config_json` JSON column on CommitRow
2. `tract.commit(..., generation_config={...})` stores the config and returns it in CommitInfo
3. `CompiledContext.generation_configs` is a list parallel to effective commits, populated by both full compile and incremental cache paths
4. `tract.record_usage(..., generation_config={...})` updates the HEAD commit's generation_config in the database
5. `tract.query_by_config(field, operator, value)` returns matching CommitInfo list using SQL-side json_extract()
6. generation_config is NOT part of commit hash computation (content_hash identical for same content regardless of config)
7. All 220 existing tests pass with no regressions
8. 18+ new tests covering all 5 phase success criteria
</success_criteria>

<output>
After completion, create `.planning/phases/01.3-hyperparameter-config-storage/01.3-01-SUMMARY.md`
</output>
